using PLR.AST;
using PLR.AST.Expressions;
using PLR.AST.Processes;
using Action = PLR.AST.Actions.Action;

COMPILER CCS s
    
    private ProcessSystem system = new ProcessSystem();
    public ProcessSystem System {get { return this.system;}}
    
CHARACTERS
  ucaseletter = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".
  lcaseletter = "abcdefghijklmnopqrstuvwxyz".
  letter = ucaseletter + lcaseletter.   
  digit = "0123456789".
  cr  = '\r'.    
  lf  = '\n'.
  tab = '\t'.  
  space = ' '.      
  underscore = '_'.      
     
TOKENS    
  PROCNAME   = ucaseletter {letter|digit} {'\''} .
  PROCNAMESUB= ucaseletter {letter|digit} {'\''} '_'.
  LCASEIDENT = lcaseletter {letter|digit}.
  OUTACTION  = underscore lcaseletter {letter|digit} underscore.
  NUMBER = digit {digit}.
  ENTRYPROC = "->".

COMMENTS FROM "#" TO lf
IGNORE cr + lf + tab

PRODUCTIONS

CCS                                                   
=   
    			                                        (. ProcessDefinition proc; .)						       
	ProcessDefinition<out proc>                         (. this.System.Add(proc); .)
    {
        ProcessDefinition<out proc>                     (. this.System.Add(proc); .)
    }                                                   (. this.System.CopyPos(this.System[0],t); .)
.  

ProcessDefinition<out ProcessDefinition procdef> =      (. procdef = new ProcessDefinition(); Process proc; ProcessConstant pc; .)
    [
    ENTRYPROC                                           (. procdef.EntryProc = true; .)
    ]
    ProcessConstantDef<out pc>                          (. procdef.ProcessConstant = pc; .)
    '='
    Process<out proc>                                   (. procdef.Process = proc; procdef.CopyPos(pc,t); .)
.

ProcessConstantDef<out ProcessConstant pc>              (. pc = new ProcessConstant(); .)
=
    PROCNAME                                            (. pc.Name = t.val; pc.SetPos(t);.)
    
    |
    
    PROCNAMESUB                                         (. pc.Name = t.val.Replace("_","");  pc.SetPos(t); ArithmeticExpression subscript; .)
    '{'                                                 (. Token startToken = t; .)
    Subscript<out subscript>                            (. pc.Subscript.Add(subscript); .)
    {
        ',' Subscript<out subscript>                    (. pc.Subscript.Add(subscript); .)
    }
    '}'                                                 (. pc.Subscript.SetPos(startToken); pc.Subscript.Length = t.pos - pc.Subscript.Pos; .)
.

Subscript<out ArithmeticExpression sub>                 (. sub = null; .)
=
    LCASEIDENT                                          (. sub = new Variable(t.val); sub.SetPos(t); .)
    |
    NUMBER|'0'                                          (. sub = new Constant(int.Parse(t.val)); sub.SetPos(t); .)
.

Process<out Process proc>                               
=   
    NonDeterministicChoice<out proc>       
.

NonDeterministicChoice<out Process proc>                (. Process pc; NonDeterministicChoice ndc = new NonDeterministicChoice();.)
=
    ParallelComposition<out pc>                         (. ndc.Add(pc); .)
    {
        '+' ParallelComposition<out pc>                 (. ndc.Add(pc); .)
    }                                                   (. if (ndc.Count == 1) {proc = ndc[0]; }else {proc = ndc; proc.CopyPos(ndc[0],t);}.)
.

ParallelComposition<out Process proc>                   (. Process ap; ParallelComposition pc = new ParallelComposition();.)
=
    ActionPrefix<out ap>                                (. pc.Add(ap); .)
    {
        '|' ActionPrefix<out ap>                        (. pc.Add(ap); .)
    }                                                   (. if (pc.Count == 1) proc = pc[0]; else {proc = pc; proc.CopyPos(pc[0],t);}.)
.

ActionPrefix<out Process proc>                          (. ActionPrefix ap = null; ActionPrefix prev = null; ActionPrefix first = null; Process nextProc = null; ProcessConstant pc; proc = null; Action act = null; .)
=
    { 
        Action<out act> '.'                             (. ap = new ActionPrefix(act); ap.CopyPos(ap.Action,t); if (first == null) first = ap; if (prev != null) { prev.Process = ap;} prev = ap;.)
    }
    (
        '(' Process<out nextProc> ')'                   (. nextProc.ParenCount++; .)
        |
        '0'                                             (. nextProc = new NilProcess(); nextProc.SetPos(t);.)
        |
        ProcessConstantInvoke<out pc>                   (. nextProc = pc; .)
    )                                                   (. if (first == null) proc = nextProc; else {ap.Process = nextProc; proc = first;}; .)

    [Relabelling<nextProc.Relabelling>]
    [Restriction<nextProc.Restrictions>]
.

ProcessConstantInvoke<out ProcessConstant pc>           (. pc = new ProcessConstant(); .)
=
    PROCNAME                                            (. pc.Name = t.val; pc.SetPos(t); .)
    
    |
    
    PROCNAMESUB                                         (. pc.Name = t.val.Replace("_","");  pc.SetPos(t); ArithmeticExpression subscript; .)
    '{'
    ArithmeticExpression<out subscript>                 (. pc.Subscript.Add(subscript); .)
    {
        ',' ArithmeticExpression<out subscript>         (. pc.Subscript.Add(subscript); .)
    }
    '}'
.

Action<out Action act>                                  (. act = null; .)
=
    't'                                                 (. act = new TauAction(); act.SetPos(t); .)
    |
    LCASEIDENT                                          (. act = new InAction(t.val); act.SetPos(t);.)
    |
    OUTACTION                                           (. if (t.val == "_t_") SemErr("Tau actions cannot be output actions!"); act = new OutAction(t.val); act.SetPos(t);.) 
.

Relabelling<Relabellings labels>                        (. string relabelTo, relabelFrom; .)
=
    '['                                                 (. labels.SetPos(t); .)
        LCASEIDENT                                      (. relabelTo = t.val; .)
        '/'
        LCASEIDENT                                      (. relabelFrom = t.val; labels.Add(relabelFrom, relabelTo); .)
        {
            ','
            LCASEIDENT                                  (. relabelTo = t.val; .)
            '/'
            LCASEIDENT                                  (. relabelFrom = t.val; labels.Add(relabelFrom, relabelTo); .)
        }
    ']'
.

Restriction<Restrictions res>          
=
    '\\'
    (
        LCASEIDENT                                      (. res.Add(t.val); res.SetPos(t); res.HasParens = false; .)
        |
        (
            '{'                                         (. res.HasParens = true; .)
            LCASEIDENT                                  (. res.Add(t.val); res.SetPos(t); .)
            {
                ',' 
                LCASEIDENT                              (. res.Add(t.val); .)
            }
            '}'
        )
    )        
.

ArithmeticExpression<out ArithmeticExpression aexp>     (. ArithmeticBinOp op; ArithmeticExpression right = null, left = null; .)
=
    PlusMinusTerm<out left>                             (. aexp = left; .)
    {
        (
            '+'                                         (. op = ArithmeticBinOp.Plus; .)
            |
            '-'                                         (. op = ArithmeticBinOp.Minus; .)
        )
        PlusMinusTerm<out right>                        (. aexp = new ArithmeticBinOpExpression(aexp, right, op); aexp.CopyPos(((ArithmeticBinOpExpression)aexp).Left,t);.)
    }
.

PlusMinusTerm<out ArithmeticExpression aexp>            (. ArithmeticBinOp op; ArithmeticExpression right = null, left = null; .)
=
    UnaryMinusTerm<out left>                            (. aexp = left; .)
    {
        (
            '*'                                         (. op = ArithmeticBinOp.Multiply; .)
            |
            '/'                                         (. op = ArithmeticBinOp.Divide; .)
            |
            '%'                                         (. op = ArithmeticBinOp.Modulo; .)
        )
        UnaryMinusTerm<out right>                       (. aexp = new ArithmeticBinOpExpression(aexp, right, op); aexp.CopyPos(((ArithmeticBinOpExpression)aexp).Left,t); .)
    }
.

UnaryMinusTerm<out ArithmeticExpression aexp>           (. bool isMinus = false; Token minusToken = null; aexp = null; .)
=
    [
        '-'                                             (. isMinus = true; minusToken = t; .)
    ]                                   
    
    (
        '(' ArithmeticExpression<out aexp> ')'          (. aexp.ParenCount += 1; .)
        |
        NUMBER                                          (. aexp = new Constant(int.Parse(t.val)); aexp.SetPos(t); .)
        |
        '0'                                             (. aexp = new Constant(int.Parse(t.val)); aexp.SetPos(t);.)
        |
        LCASEIDENT                                      (. aexp = new Variable(t.val); aexp.SetPos(t); .)
    )
                                                        (. if (isMinus) {aexp = new UnaryMinus(aexp); aexp.SetPos(minusToken);} .)
.

END CCS.