using PLR.AST;
using PLR.AST.Expressions;
using PLR.AST.Processes;
using PLR.AST.Actions;
using PLR.AST.ActionHandling;
using Action = PLR.AST.Actions.Action;
using System.Collections.Generic;

COMPILER CCS  
    
    private ProcessSystem system = new ProcessSystem();
    public ProcessSystem System {get { return this.system;}}
    
    private void SetPos(Node n, Token t) {
        n.LexicalInfo.StartLine = t.line;
        n.LexicalInfo.StartColumn = t.col;
        n.LexicalInfo.EndLine = t.line;
        n.LexicalInfo.EndColumn = t.col+t.val.Length;
    }
    
    private void SetStartPos(Node n, Token t) {
        n.LexicalInfo.StartLine = t.line;
        n.LexicalInfo.StartColumn = t.col;
    }

    private void SetEndPos(Node n, Token t) {
        n.LexicalInfo.EndLine = t.line;
        n.LexicalInfo.EndColumn = t.col;
    }
    
    private void CopyPos(Node n, Node source, Token end) {
        n.LexicalInfo.StartLine = source.LexicalInfo.StartLine;
        n.LexicalInfo.StartColumn = source.LexicalInfo.StartColumn;
        n.LexicalInfo.EndLine = t.line;
        n.LexicalInfo.EndColumn = t.col;
    }

CHARACTERS
  ucaseletter = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".
  lcaseletter = "abcdefghijklmnopqrstuvwxyz".
  letter = ucaseletter + lcaseletter.   
  digit = "0123456789".
  cr  = '\r'.    
  lf  = '\n'.
  tab = '\t'.  
  space = ' '.
  anyButQuote = ANY - '"'.
  underscore = '_'.      
     
TOKENS    
  PROCNAME   = ucaseletter {letter|digit} {'\''} .
  PROCNAMESUB= ucaseletter {letter|digit} {'\''} '_'.
  LCASEIDENT = lcaseletter {letter|digit}.
  CLASSNAME  = ucaseletter {letter|digit}  '.' ucaseletter {letter|digit} { '.' ucaseletter {letter|digit}}.
  OUTACTION  = underscore lcaseletter {letter|digit} underscore.
  METHOD     = ':' letter {letter|digit} .
  NUMBER = digit {digit}.
  STRING = '"' {anyButQuote} '"'.

COMMENTS FROM "#" TO lf
IGNORE cr + lf + tab

PRODUCTIONS

CCS                                                   
=   
	{ ClassImport<> }
    			                                        (. ProcessDefinition proc; .)						       
	ProcessDefinition<out proc, true>                   (. this.System.Add(proc); .)
    {
        ProcessDefinition<out proc, false>              (. this.System.Add(proc); .)
    }                                                   (. CopyPos(this.System, this.System[0], t); .)
.  

ClassImport<>
=
	"use" CLASSNAME										(. this.System.AddImport(t.val); .)
.

ProcessDefinition<out ProcessDefinition procdef, bool entryProc> =      (. Process proc; ProcessConstant pc; .)
    ProcessConstantDef<out pc>                          
    '='
    Process<out proc>                                   (. procdef = new ProcessDefinition(pc, proc, entryProc); CopyPos(procdef,pc,t); .)
.

ProcessConstantDef<out ProcessConstant pc>				(. pc = null; .)
=
    PROCNAME                                            (. pc = new ProcessConstant(t.val); SetPos(pc, t);.)
    
    |
    
    PROCNAMESUB                                         (. pc = new ProcessConstant(t.val.Replace("_",""));  SetPos(pc,t); ArithmeticExpression subscript; .)
    '{'                                                 (. Token startToken = t; .)
    Subscript<out subscript>                            (. pc.Subscript.Add(subscript); .)
    {
        ',' Subscript<out subscript>                    (. pc.Subscript.Add(subscript); .)
    }
    '}'                                                 (. SetPos(pc.Subscript,startToken); .)
.

Subscript<out ArithmeticExpression sub>                 (. sub = null; .)
=
    LCASEIDENT                                          (. sub = new Variable(t.val); SetPos(sub, t); .)
    |
    NUMBER|'0'                                          (. sub = new Number(int.Parse(t.val)); SetPos(sub, t); .)
.

Process<out Process proc>                               
=   
    NonDeterministicChoice<out proc>       
.

NonDeterministicChoice<out Process proc>                (. Process pc; NonDeterministicChoice ndc = new NonDeterministicChoice();.)
=
    ParallelComposition<out pc>                         (. ndc.Add(pc); .)
    {
        '+' ParallelComposition<out pc>                 (. ndc.Add(pc); .)
    }                                                   (. if (ndc.Count == 1) {proc = ndc[0]; }else {proc = ndc; CopyPos(proc,ndc[0], t);}.)
.

ParallelComposition<out Process proc>                   (. Process ap; ParallelComposition pc = new ParallelComposition();.)
=
    ActionPrefix<out ap>                                (. pc.Add(ap); .)
    {
        '|' ActionPrefix<out ap>                        (. pc.Add(ap); .)
    }                                                   (. if (pc.Count == 1) proc = pc[0]; else {proc = pc; CopyPos(pc[0],proc,t);}.)
.

ActionPrefix<out Process proc>                          (. ActionPrefix ap = null; ActionPrefix prev = null; ActionPrefix first = null; Process nextProc = null; ProcessConstant pc; proc = null; Action act = null; .)
=
    { 
        Action<out act> '.'                             (. ap = new ActionPrefix(act, null); CopyPos(ap,ap.Action,t); if (first == null) first = ap; if (prev != null) { prev.Process = ap;} prev = ap;.)
    }
    (
        '(' Process<out nextProc> ')'                   (. nextProc.ParenCount++; .)
        |
        '0'                                             (. nextProc = new NilProcess(); SetPos(nextProc, t);.)
        |
        ProcessConstantInvoke<out pc>                   (. nextProc = pc; .)
    )                                                   (. if (first == null) proc = nextProc; else {ap.Process = nextProc; proc = first;}; .)

    [													(. PreProcessActions ppa = null; .)
    Relabelling<out ppa>								(. nextProc.PreProcessActions = ppa; .)
    ]
    [													(. ActionRestrictions ar = null; .)
    Restriction<out ar>									(. nextProc.ActionRestrictions = ar; .)
    ]
.

ProcessConstantInvoke<out ProcessConstant pc>           (. pc = null; .)
=
    PROCNAME                                            (. pc = new ProcessConstant(t.val); SetPos(pc, t); .)
    
    |
    
    PROCNAMESUB                                         (. pc = new ProcessConstant(t.val.Replace("_",""));  SetPos(pc, t); ArithmeticExpression subscript; .)
    '{'
    ArithmeticExpression<out subscript>                 (. pc.Subscript.Add(subscript); .)
    {
        ',' ArithmeticExpression<out subscript>         (. pc.Subscript.Add(subscript); .)
    }
    '}'
.

Action<out Action act>                                  (. act = null; .)
=
    LCASEIDENT                                          (. act = new InAction(t.val); SetPos(act, t);.)
    |
    OUTACTION                                           (. act = new OutAction(t.val); SetPos(act, t);.) 
    |
    METHOD												(. Token start = t; List<object> list = new List<object>(); Expression exp = null; string methodName = t.val.Replace(":",""); Token callStart = t; .) 
    '('
    [
		CallParam<out exp>								(. list.Add(exp); .)
		
		{
			','
			CallParam<out exp>							(. list.Add(exp); .)
		}	
    
    ]
    ')'													(. act = new Call(new MethodCallExpression(methodName, list.ToArray())); SetStartPos(act, start); SetEndPos(act, t); .)
.

CallParam<out Expression exp>							(. ArithmeticExpression aexp = null; exp = null;.)
=
	ArithmeticExpression<out aexp>						(. exp = aexp; .)
	|
	STRING												(. exp = new PLRString(t.val.Substring(1, t.val.Length-2)); SetPos(exp, t);.)
.

Relabelling<out PreProcessActions preproc>               (. preproc = null; string relabelTo, relabelFrom; RelabelActions labels = new RelabelActions(); .)
=
    '['                                                 (. Token first = t; .)
    (
		METHOD											(. preproc = new CustomPreprocess(t.val.Replace(":","")); SetPos(preproc, first);.)
		|
        LCASEIDENT                                      (. relabelTo = t.val; SetPos(labels, first);.)
        '/'
        LCASEIDENT                                      (. relabelFrom = t.val; labels.Add(relabelFrom, relabelTo); .)
        {
            ','
            LCASEIDENT                                  (. relabelTo = t.val; .)
            '/'
            LCASEIDENT                                  (. relabelFrom = t.val; labels.Add(relabelFrom, relabelTo); .)
        }												(. preproc = labels; .)
     )
    ']'
.

Restriction<out ActionRestrictions ar>          
=														(. ar = null; ChannelRestrictions res = new ChannelRestrictions(); .)
    '\\'
    (
        LCASEIDENT                                      (. res.Add(t.val); SetPos(res, t); res.ParenCount = 0; ar = res; .)
        |
        (
            '{'                                         (. res.ParenCount = 1; .)
            LCASEIDENT                                  (. res.Add(t.val); SetPos(res, t); .)
            {
                ',' 
                LCASEIDENT                              (. res.Add(t.val); .)
            }
            '}'											(. ar = res; .)
        )
        |
        METHOD											(. ar = new CustomRestrictions(t.val.Replace(":", "")); SetPos(ar, t); .)
    )        
.

ArithmeticExpression<out ArithmeticExpression aexp>		(. ArithmeticBinOp op; ArithmeticExpression right = null, left = null; .)
=
    PlusMinusTerm<out left>                             (. aexp = left; .)
    {
        (
            '+'                                         (. op = ArithmeticBinOp.Plus; .)
            |
            '-'                                         (. op = ArithmeticBinOp.Minus; .)
        )
        PlusMinusTerm<out right>                        (. aexp = new ArithmeticBinOpExpression(aexp, right, op); CopyPos(((ArithmeticBinOpExpression)aexp).Left,aexp,t);.)
    }
.

PlusMinusTerm<out ArithmeticExpression aexp>            (. ArithmeticBinOp op; ArithmeticExpression right = null, left = null; .)
=
    UnaryMinusTerm<out left>                            (. aexp = left; .)
    {
        (
            '*'                                         (. op = ArithmeticBinOp.Multiply; .)
            |
            '/'                                         (. op = ArithmeticBinOp.Divide; .)
            |
            '%'                                         (. op = ArithmeticBinOp.Modulo; .)
        )
        UnaryMinusTerm<out right>                       (. aexp = new ArithmeticBinOpExpression(aexp, right, op); CopyPos(((ArithmeticBinOpExpression)aexp).Left,aexp,t); .)
    }
.

UnaryMinusTerm<out ArithmeticExpression aexp>           (. bool isMinus = false; Token minusToken = null; aexp = null; .)
=
    [
        '-'                                             (. isMinus = true; minusToken = t; .)
    ]                                   
    
    (
        '(' ArithmeticExpression<out aexp> ')'          (. aexp.ParenCount += 1; .)
        |
        NUMBER                                          (. aexp = new Number(int.Parse(t.val)); SetPos(aexp, t); .)
        |
        '0'                                             (. aexp = new Number(int.Parse(t.val)); SetPos(aexp, t);.)
        |
        LCASEIDENT                                      (. aexp = new Variable(t.val); SetPos(aexp, t); .)
    )
                                                        (. if (isMinus) {aexp = new UnaryMinus(aexp); SetPos(aexp, minusToken);} .)
.

END CCS.