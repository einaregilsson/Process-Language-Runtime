/**
 * $Id$ 
 * 
 * This file is part of the Process Language Runtime (PLR) 
 * and is licensed under the GPL v3.0.
 * 
 * Author: Einar Egilsson (einar@einaregilsson.com) 
 */
 /*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
----------------------------------------------------------------------*/
using System;
using PLR.Analysis;
using PLR.AST;
using PLR;

namespace CCS.Parsing {

    public partial class Parser {

        const bool T = true;
        const bool x = false;
        const int minErrDist = 2;

        public Scanner scanner;
        public Errors errors;

        public Token t;    // last recognized token
        public Token la;   // lookahead token
        int errDist = minErrDist;

        public Parser(Scanner scanner) {
            this.scanner = scanner;
            errors = new Errors();
        }

        bool StartOf(int s) {
            return set[s, la.kind];
        }

        private ProcessSystem system = new ProcessSystem();
        public ProcessSystem System { get { return this.system; } }

        private void SetPos(Node n, Token t) {
            n.LexicalInfo.StartLine = t.line;
            n.LexicalInfo.StartColumn = t.col;
            n.LexicalInfo.EndLine = t.line;
            n.LexicalInfo.EndColumn = t.col + t.val.Length;
        }

        private void SetPos(Node n, Token start, Token end) {
            n.LexicalInfo.StartLine = start.line;
            n.LexicalInfo.StartColumn = start.col;
            n.LexicalInfo.EndLine = end.line;
            n.LexicalInfo.EndColumn = end.col + end.val.Length;
        }

        private void SetStartPos(Node n, Token t) {
            n.LexicalInfo.StartLine = t.line;
            n.LexicalInfo.StartColumn = t.col;
        }

        private void SetEndPos(Node n, Token t) {
            n.LexicalInfo.EndLine = t.line;
            n.LexicalInfo.EndColumn = t.col;
        }

        private void CopyPos(Node n, Node source, Token end) {
            n.LexicalInfo.StartLine = source.LexicalInfo.StartLine;
            n.LexicalInfo.StartColumn = source.LexicalInfo.StartColumn;
            n.LexicalInfo.EndLine = end.line;
            n.LexicalInfo.EndColumn = end.col + end.val.Length;
        }


        void SynErr(int n) {
            if (errDist >= minErrDist) errors.SynErr(la.line, la.col, n);
            errDist = 0;
        }

        public void SemErr(string msg) {
            if (errDist >= minErrDist) errors.SemErr(t.line, t.col, msg);
            errDist = 0;
        }

        void Expect(int n) {
            if (la.kind == n) Get(); else { SynErr(n); }
        }

    } // end Parser


    public partial class Errors {
        public int count = 0;                                    // number of errors detected
        public System.IO.TextWriter errorStream = Console.Out;   // error messages go to this stream

        public void SynErr(int line, int col, int n) {
            string s;
            s = GetErrorMessage(n);
            if (s == null) {
                s = "error " + n;
            }
            errorStream.WriteLine("ERROR({0},{1}): {2}", line, col, s);
            count++;
        }

        public void SemErr(int line, int col, string s) {
            errorStream.WriteLine("ERROR({0},{1}): {2}", line, col, s);
            count++;
        }


        public void Warning(int line, int col, string s) {
            errorStream.WriteLine("WARNING({0},{1}): {2}", line, col, s);
        }

    } // Errors


    public class FatalError : Exception {
        public FatalError(string m) : base(m) { }
    }
}