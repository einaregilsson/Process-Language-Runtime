COMPILER Program
	

def ExpectBool(exp as Expression, t as Token, isRightHandSide as bool):
	if not exp isa BoolExpression:
		if isRightHandSide:
			errors.SemErr(t.line, t.col, "'${t.val}' expects a boolean expression on its right side")
		else:
			errors.SemErr(t.line, t.col, "'${t.val}' expects a boolean expression on its left side")
		return false
	return true
		
def ExpectInt(exp as Expression, t as Token, isRightHandSide as bool):
	if not exp isa IntExpression:
		if isRightHandSide:
			errors.SemErr(t.line, t.col, "'${t.val}' expects a integer expression on its right side")
		else:
			errors.SemErr(t.line, t.col, "'${t.val}' expects a integer expression on its left side")
		return false
	return true

def ExpectIntArg(exp as Expression, t as Token):
	if not exp isa IntExpression:
		errors.SemErr(t.line, t.col, "Arguments to procedures can only be integer expressions")

def IsStartOfResultArg() as bool:
	t as Token = scanner.Peek()
	scanner.ResetPeek()
	return t.val == "res"

def IsProcProgram() as bool:
	t as Token = scanner.Peek()
	scanner.ResetPeek()
	return t.val == "proc"

CHARACTERS
  letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
  digit = "0123456789".
  cr  = '\r'.
  lf  = '\n'.
  tab = '\t'.

TOKENS
  ident  = letter {letter | digit}.
  number = digit {digit}.

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf
COMMENTS FROM "#" TO lf

IGNORE cr + lf + tab

PRODUCTIONS

Program<>
=                                          				(.	statements as StatementSequence
															procs = Dictionary[of string, Procedure]() .)

   	(
    IF(IsProcProgram()) 
    	"begin"
    	Proc<procs>
    	{
    		Proc<procs>
    	}
    	StmtSeq<statements>
    	"end"
    |
    	StmtSeq<statements>
    )
    
    													(.	WhileTree.SetParseResults(statements, procs) .)
.

Proc<procs as Dictionary[of string, Procedure]>
=														(.	statements as StatementSequence
															name as string 
															valArgs = List[of Variable]()
															resultArg as Variable .)
	"proc"												(.	ptok = t .)
	ident												(.	name = t.val .)
	"("
	[
		(
			"val"
			ident										(.	valArgs.Add(Variable(t.val,IsValueArg:true))
															VariableStack.DefineArgument(t.val) .)
			[Args<valArgs, resultArg>]
		|
			"res"
			ident										(.	resultArg = Variable(t.val,IsResultArg:true)
															VariableStack.DefineArgument(t.val).)
		)
	]
	")"
	"is"
	StmtSeq<statements>
	"end"
	";"													(.	if procs.ContainsKey(name):
																errors.SemErr(ptok.line, ptok.col, "Procedure '${name}' is already declared")
															else:
																procs.Add(name, Procedure(name, valArgs, resultArg, statements))
															VariableStack.Clear()
														.)
.

Args<valArgs as List[of Variable], ref resultArg as Variable> 
=
	(
	IF(IsStartOfResultArg()) 
	","
	"res" 
	ident									(.	resultArg = Variable(t.val,IsResultArg:true)
												if VariableStack.IsDeclaredInCurrentScope(t.val):
													errors.SemErr(t.line, t.col, "Argument '${t.val}' is already declared in this scope")
												else:
													VariableStack.DefineArgument(t.val)
											.)
	|
	","
	ident									(.	valArgs.Add(Variable(t.val,IsValueArg:true)) 
												if VariableStack.IsDeclaredInCurrentScope(t.val):
													errors.SemErr(t.line, t.col, "Argument '${t.val}' is already declared in this scope")
												else:
													VariableStack.DefineArgument(t.val)
											.)
	[Args<valArgs, resultArg>] 
	)
.

StmtSeq<ref statements as StatementSequence>  
=													(. 	stmt as Statement 
														slist = List[of Statement]().)
    Stmt<stmt>                         				(. slist.Add(stmt) .)
    {
        ';' Stmt<stmt>                 				(. slist.Add(stmt) .)
    }                                      			(. statements = StatementSequence(slist) .)
.

Stmt<ref stmt as Statement>                   
=													(. 	exp as Expression 
														sl,sc = la.line, la.col .)

	( AssignStmt<stmt>								(. stmt.AddSequencePoint(sl,sc, t.line,t.col+t.val.Length) .)
	| "skip"                               			(. stmt = Skip();stmt.AddSequencePoint(t.line,t.col, t.line,t.col+t.val.Length) .)
	| BlockStmt<stmt>                       
	| IfStmt<stmt>
	| WhileStmt<stmt>
	| ReadStmt<stmt>								(. 	stmt.AddSequencePoint(sl,sc, t.line,t.col+t.val.Length).)
	| "write" Expr<exp>                				(. 	stmt = Write(exp); stmt.AddSequencePoint(sl,sc, t.line,t.col+t.val.Length) .)
	| CallProc<stmt>								(. 	stmt.AddSequencePoint(sl,sc, t.line,t.col+t.val.Length) .)
	)
.

ReadStmt<ref stmt as Statement>
=
	"read" 
	(
		ident                         				(. 	stmt = Read(Variable(t.val)) .)
		|
		'(' 
		ident										(. 	stmt = Read(Variable(t.val)) .)
		')'
	)
.

VarDecStmt<ref vars as VariableDeclarationSequence>
=													(. list = List[of VariableDeclaration]() .)
	VarDec<list>
	{
	    VarDec<list>
	}												(. vars = VariableDeclarationSequence(list) .)
.

VarDec<list as List[of VariableDeclaration]>
=
	"var" 											(. sl,sc,el,ec = t.line,t.col,la.line,la.col+la.val.Length .)
	ident                             				(. 	if VariableStack.IsDeclaredInCurrentScope(t.val):
															errors.SemErr(t.line, t.col, "Variable '${t.val}' is already declared in this scope") 
														elif VariableStack.IsInScope(t.val):
															errors.Warning(t.line, t.col, "Variable '${t.val}' hides variable with same name in outer block")
															VariableStack.DefineVariable(t.val)
														else:
															VariableStack.DefineVariable(t.val) 
														vd = VariableDeclaration(Variable(t.val))
														vd.AddSequencePoint(sl,sc,el,ec)
														list.Add(vd) .)
	';'
.

BlockStmt<ref block as Statement>                 
=
	"begin"                                 		(.	if CompileOptions.BookVersion:
															errors.SemErr(t.line, t.col, "The book version of the While syntax (/book switch) does not allow begin-end blocks (unless at the very beginning of a procedure program) or variable declarations")
															System.Environment.Exit(1)
														vars as VariableDeclarationSequence
														VariableStack.PushScope()
														sl,sc,el,ec = t.line,t.col,t.line,t.col+t.val.Length .)
	[ VarDecStmt<vars> ]							(. statements as StatementSequence .)
	StmtSeq<statements>                
	"end"                       					(. 	block = Block(vars, statements) 
														block.AddSequencePoint(sl,sc,el,ec)
														block.AddSequencePoint(t.line,t.col, t.line, t.col+t.val.Length)
														VariableStack.PopScope() .)
.

AssignStmt<ref assign as Statement>            		(. 	exp as Expression 
														var as Variable .)
=	ident                                  			(. 	var = Variable(t.val) 
														if not VariableStack.IsInScope(t.val) and not CompileOptions.BookVersion:
																errors.SemErr(t.line, t.col, "Assignment to undeclared variable '${t.val}'") .)
	":="											(. tok = t .)
	Expr<exp>                          				(. return unless ExpectInt(exp, tok, true) .)
													(. assign = Assign(var, exp) .)
.

IfStmt<ref ifStmt as Statement>           			(. 	ifBranch as StatementSequence; 
														elseBranch as StatementSequence
														exp as Expression .)
=
	"if"											(.  sl,sc,tok = t.line, t.col, t .)
	Expr<exp>										(.	return unless ExpectBool(exp, tok, true) .)
	"then"											(. 	el,ec = t.line, t.col+t.val.Length .)
	
	(
		IF(CompileOptions.BookVersion) IfBookBody<ifBranch, elseBranch>
		|
		IfCourseBody<ifBranch, elseBranch>
	)
		                                  			(. 	ifStmt = If(exp, ifBranch, elseBranch) 
														ifStmt.AddSequencePoint(sl,sc,el,ec)
														ifStmt.AddSequencePoint(t.line,t.col, t.line, t.col+t.val.Length).)
.


IfCourseBody<ref ifBranch as StatementSequence, ref elseBranch as StatementSequence>
=
	StmtSeq<ifBranch>
	[
	    "else"
	    StmtSeq<elseBranch>
	]
	"fi"
.

IfBookBody<ref ifBranch as StatementSequence, ref elseBranch as StatementSequence>
=
	PossibleCompoundStatement<ifBranch>
	[
	    "else"
	    PossibleCompoundStatement<elseBranch>
	]
.

PossibleCompoundStatement<ref stmtSeq as StatementSequence>
=													(.	stmt as Statement .)
	Stmt<stmt>										(.	stmtSeq = StatementSequence((stmt,)) .)
	|
	'('
	StmtSeq<stmtSeq>
	')'
.


WhileStmt<ref whileStmt as Statement>          		(.	exp as Expression
														whileBranch as StatementSequence .)
=
	"while"											(. 	sl,sc,tok = t.line, t.col,t .)
	Expr<exp>										(. 	return unless ExpectBool(exp, tok, true) .)
	"do"											(.	el,ec = t.line, t.col+t.val.Length .)
	(
		IF(CompileOptions.BookVersion)
		PossibleCompoundStatement<whileBranch>
	|
		StmtSeq<whileBranch>
		"od"
	)
		                                   			(. 	whileStmt = While(exp, whileBranch) 
														whileStmt.AddSequencePoint(sl,sc,el,ec)
														whileStmt.AddSequencePoint(t.line,t.col, t.line, t.col+t.val.Length).)
.

CallProc<ref callStmt as Statement>
=													(.	exp as Expression
														list = List[of Expression]()	.)
	"call"											(.	callToken = t 
														exprToken as Token.)
	ident											(.	proc = t.val .)
	"("
	[
													(.	exprToken = la .)
		Expr<exp>									(.	list.Add(exp); ExpectIntArg(exp, exprToken) .)
		{ 
			"," 									(.	exprToken = la .)
			Expr<exp>								(.	list.Add(exp); ExpectIntArg(exp, exprToken) .)
		}
	]
	")"												(.	callStmt = Call(proc, list, callToken, exprToken) .)
.


Expr<ref exp as Expression>
=	
    LogicOr<exp>                      
.


LogicOr<ref exp as Expression>                	(. second as Expression .)
=	
    LogicAnd<exp>                      
    {
        "or"          							(. tok = t .)
        LogicAnd<second>						(.	return unless ExpectBool(exp, tok, false) 
													return unless ExpectBool(second, tok, true) 
													exp = LogicBinaryOp(exp, second, LogicBinaryOp.Or) .)
    }                                       
.

LogicAnd<ref exp as Expression>                	(. second as Expression .)                
=	
    LogicXor<exp>
    {                            
        "and"                    				(. 	tok = t .)
        LogicXor<second>						(.	return unless ExpectBool(exp, tok, false) 
													return unless ExpectBool(second, tok, true) 
													exp = LogicBinaryOp(exp, second, LogicBinaryOp.And) .)
    }
.

LogicXor<ref exp as Expression>                	(. second as Expression .)                
=	
    Comparison<exp>
    {                            
        "xor"                    				(. 	tok = t .)
        Comparison<second>						(.	return unless ExpectBool(exp, tok, false) 
													return unless ExpectBool(second, tok, true) 
													exp = LogicBinaryOp(exp, second, LogicBinaryOp.Xor) .)
    }
.

Comparison<ref exp as Expression>           	(.	second as Expression 
													op as string .)
=
    BitOr<exp>
    [
        (
        "<"                            			(.	op = ComparisonBinaryOp.LessThan .)
        |
        ">"                                		(.	op = ComparisonBinaryOp.GreaterThan .)
        |
        "<="                               		(.	op = ComparisonBinaryOp.LessThanOrEqual .)
        |
        ">="                               		(.	op = ComparisonBinaryOp.GreaterThanOrEqual .)
		|
        "=="                               		(.	op = ComparisonBinaryOp.Equal.)
        |
        "!="                               		(.	op = ComparisonBinaryOp.NotEqual .)
        
        )										(. 	tok = t .)
        Comparison<second>						(.	return unless ExpectInt(exp, tok, false) 
													return unless ExpectInt(second, tok, true) 
													exp = ComparisonBinaryOp(exp, second, op) .)
    ]
.

BitOr<ref exp as Expression>                	(.	second as Expression .)                  
=	
    BitXor<exp>
    {
        "|"       								(. 	tok = t .)
        BitXor<second>                 			(.	return unless ExpectInt(exp, tok, false) 
													return unless ExpectInt(second, tok, true) 
													exp = BitBinaryOp(exp, second, BitBinaryOp.Or) .)
    }
.

BitXor<ref exp as Expression>                	(.	second as Expression .)                 
=	
    BitAnd<exp>
    {
        "^"     								(.	tok = t .)
        BitAnd<second>                 			(.	return unless ExpectInt(exp, tok, false) 
													return unless ExpectInt(second, tok, true) 
													exp = BitBinaryOp(exp, second, BitBinaryOp.Xor) .)
    }
.

BitAnd<ref exp as Expression>                	(.	second as Expression .)                 
=	
    BitShift<exp>
    {
        "&"                             		(. 	tok = t .)
        BitShift<second>                  		(.	return unless ExpectInt(exp, tok, false) 
													return unless ExpectInt(second, tok, true) 
													exp = BitBinaryOp(exp, second, BitBinaryOp.And) .)
    }
.

BitShift<ref exp as Expression>                	(.	second as Expression
													op as string .)               
=	
    PlusMinus<exp>
    {
        (
        "<<"                               		(.	op = BitBinaryOp.ShiftLeft .)
        |
        ">>"                               		(.	op = BitBinaryOp.ShiftRight .)
        )             							(. 	tok = t .)
        PlusMinus<second>              			(.	return unless ExpectInt(exp, tok, false) 
													return unless ExpectInt(second, tok, true) 
													exp = BitBinaryOp(exp, second, op).)
    }
.

PlusMinus<ref exp as Expression>                (. 	second as Expression 
													op as string.)              
=	
    MulDivMod<exp>
    {
        (
        "+"                                		(. 	op = ArithmeticBinaryOp.Plus .)
        |
        "-"                                		(. 	op = ArithmeticBinaryOp.Minus .)
        )             							(. 	tok = t .)
        MulDivMod<second>              			(.	return unless ExpectInt(exp, tok, false) 
													return unless ExpectInt(second, tok, true) 
													exp = ArithmeticBinaryOp(exp, second, op) .)
    }
.

MulDivMod<ref exp as Expression>                (. second as Expression .)              
=	
    UnaryOperator<exp>
    {
        (
        "*"                                		(. 	op = ArithmeticBinaryOp.Multiplication .)
        |
        "/"                                		(. 	op = ArithmeticBinaryOp.Division .)
        |
        "%"                                		(. 	op = ArithmeticBinaryOp.Modulo .)
        )             							(. 	tok = t .)
        UnaryOperator<second>          			(.	return unless ExpectInt(exp, tok, false) 
													return unless ExpectInt(second, tok, true) 
													exp = ArithmeticBinaryOp(exp, second, op) .)
    }
.


UnaryOperator<ref exp as Expression>          	(.	op as string = null .)
=                               
	[
	'-'                                    		(. 	op = t.val .)
	|
	'~'                                    		(. 	op = t.val .)
	|
	"not"                                  		(. 	op = t.val .)
												(.	tok = t .)
	]
	Terminal<exp>                      			(.	if op in ('-','~'): 
														return unless ExpectInt(exp, tok, true)
														exp = IntUnaryOp(exp, op)
													elif op == 'not':
														return unless ExpectBool(exp, tok, true)
														exp = NotUnaryOp(exp) .)
.

Terminal<ref exp as Expression>               
=
	( ident                                		(. 	exp = Variable(t.val) 
													if not VariableStack.IsInScope(t.val) and not CompileOptions.BookVersion:
														errors.SemErr(t.line, t.col, "Undeclared variable '${t.val}'") .)
	| number                               		(. exp = Number(int.Parse(t.val)) .)
	| "true"                               		(. exp = Bool(true) .)
	| "false"                              		(. exp = Bool(false) .)
	| '(' Expr<exp> ')'
	)
.

END Program.
