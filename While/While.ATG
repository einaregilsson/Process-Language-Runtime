COMPILER Program
	
	#Node
	[Getter(AbstractSyntaxTree)]
	_ast as WhileTree

CHARACTERS
  letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
  digit = "0123456789".
  cr  = '\r'.
  lf  = '\n'.
  tab = '\t'.

TOKENS
  ident  = letter {letter | digit}.
  number = digit {digit}.

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf
COMMENTS FROM "#" TO lf

IGNORE cr + lf + tab

PRODUCTIONS

Program<>
=                                          			(.	statements as StatementSequence.)
    StmtSeq<statements>								(.	_ast = WhileTree(statements) .)
.

StmtSeq<ref statements as StatementSequence>  
=													(. stmt as Statement 
													   slist = List[of Statement]().)
    Stmt<stmt>                         				(. slist.Add(stmt) .)
    {
        ';' Stmt<stmt>                 				(. slist.Add(stmt) .)
    }                                      			(. statements = StatementSequence(slist) .)
.

Stmt<ref stmt as Statement>                   
=													(. exp as Expression .)
	( AssignStmt<stmt>
	| "skip"                               			(. stmt = Skip() .)
	| BlockStmt<stmt>                       
	| IfStmt<stmt>
	| WhileStmt<stmt>
	| "read" ident                         			(. stmt = Read(Variable(t.val)) .)
	| "write" Expr<exp>                				(. stmt = Write(exp) .)
	)
.

VarDecStmt<ref vars as VariableDeclarationSequence>
=													(. list = List[of VariableDeclaration]() .)
	"var" ident                             		(. list.Add(VariableDeclaration(Variable(t.val))) .)
	';'
	{
	    "var" ident                    				(. list.Add(VariableDeclaration(Variable(t.val))) .)
	    ';'
	}												(. vars = VariableDeclarationSequence(list) .)
.

BlockStmt<ref block as Statement>                 
=
	"begin"                                 		(. vars as VariableDeclarationSequence.)
	[ VarDecStmt<vars> ]							(. statements as StatementSequence .)
	StmtSeq<statements>                
	"end"                       					(. block = Block(vars, statements) .)
.

AssignStmt<ref assign as Statement>            		(. exp as Expression 
													   var as Variable .)
=	ident                                  			(. var = Variable(t.val) .)
	":="
	Expr<exp>                          				(. assign = Assign(var, exp) .)
.

IfStmt<ref ifStmt as Statement>           			(. 	ifBranch as StatementSequence; 
														elseBranch as StatementSequence
														exp as Expression .)
=
	"if"
	Expr<exp>
	"then"
	StmtSeq<ifBranch>
	[
	    "else"
	    StmtSeq<elseBranch>
	]
	"fi"                                  			(. ifStmt = If(exp, ifBranch, elseBranch) .) 
.

WhileStmt<ref whileStmt as Statement>          		(.	exp as Expression
														whileBranch as StatementSequence .)
=
	"while"
	Expr<exp>
	"do"
	StmtSeq<whileBranch>
	"od"                                   			(. whileStmt = While(exp, whileBranch) .)
.

Expr<ref exp as Expression>
=	
    LogicOr<exp>                      
.


LogicOr<ref exp as Expression>                	(. second as Expression .)
=	
    LogicAnd<exp>                      
    {
        "||"          
        LogicAnd<second>						(.	exp = LogicBinaryOp(exp, second, LogicBinaryOp.Or) .)
    }                                       
.

LogicAnd<ref exp as Expression>                	(. second as Expression .)                
=	
    EqualComp<exp>
    {                            
        "&&"                    
        EqualComp<second>               		(.	exp = LogicBinaryOp(exp, second, LogicBinaryOp.And) .)
    }
.

EqualComp<ref exp as Expression>                (. 	second as Expression 
													op as string .)
=	
    GreatOrEqual<exp>
    [
        (
        "=="                               		(.	op = EqualityBinaryOp.Equal .)
        |
        "!="                               		(.	op = EqualityBinaryOp.NotEqual .)
        )                         
        GreatOrEqual<second>           			(.	exp = EqualityBinaryOp(exp, second, op) .)
    ]
.

GreatOrEqual<ref exp as Expression>           	(.	second as Expression 
													op as string .)
=
    BitOr<exp>
    [
        (
        "<"                            			(.	op = ComparisonBinaryOp.LessThan .)
        |
        ">"                                		(.	op = ComparisonBinaryOp.GreaterThan .)
        |
        "<="                               		(.	op = ComparisonBinaryOp.LessThanOrEqual .)
        |
        ">="                               		(.	op = ComparisonBinaryOp.GreaterThanOrEqual .)
        )
        BitOr<second>                  			(. exp = ComparisonBinaryOp(exp, second, op) .)
    ]
.

BitOr<ref exp as Expression>                	(.	second as Expression .)                  
=	
    BitXor<exp>
    {
        "|"       
        BitXor<second>                 			(.	exp = BitBinaryOp(exp, second, BitBinaryOp.Or) .)
    }
.

BitXor<ref exp as Expression>                	(.	second as Expression .)                 
=	
    BitAnd<exp>
    {
        "^"     
        BitAnd<second>                 			(.	exp = BitBinaryOp(exp, second, BitBinaryOp.Xor) .)
    }
.

BitAnd<ref exp as Expression>                	(.	second as Expression .)                 
=	
    BitShift<exp>
    {
        "&"                             
        BitShift<second>                  		(.	exp = BitBinaryOp(exp, second, BitBinaryOp.And) .)
    }
.

BitShift<ref exp as Expression>                	(.	second as Expression
													op as string .)               
=	
    PlusMinus<exp>
    {
        (
        "<<"                               		(.	op = BitBinaryOp.ShiftLeft .)
        |
        ">>"                               		(.	op = BitBinaryOp.ShiftRight .)
        )             
        PlusMinus<second>              			(.	exp = BitBinaryOp(exp, second, op).)
    }
.

PlusMinus<ref exp as Expression>                (. 	second as Expression 
													op as string.)              
=	
    MulDivMod<exp>
    {
        (
        "+"                                		(. 	op = ArithmeticBinaryOp.Plus .)
        |
        "-"                                		(. 	op = ArithmeticBinaryOp.Minus .)
        )             
        MulDivMod<second>              			(.	exp = ArithmeticBinaryOp(exp, second, op) .)
    }
.

MulDivMod<ref exp as Expression>                (. second as Expression .)              
=	
    UnaryOperator<exp>
    {
        (
        "*"                                		(. 	op = ArithmeticBinaryOp.Multiplication .)
        |
        "/"                                		(. 	op = ArithmeticBinaryOp.Division .)
        |
        "%"                                		(. 	op = ArithmeticBinaryOp.Modulo .)
        )             
        UnaryOperator<second>          			(.	exp = ArithmeticBinaryOp(exp, second, op) .)
    }
.


UnaryOperator<ref exp as Expression>          	(.	op as string = null .)
=                               
	[
	'-'                                    		(. 	op = t.val .)
	|
	'~'                                    		(. 	op = t.val .)
	]
	Terminal<exp>                      			(. 	if op == '-': exp = MinusUnaryOp(exp) 
													elif op == '~': exp = NotUnaryOp(exp) .)
.

Terminal<ref exp as Expression>               
=
	( ident                                		(. exp = Variable(t.val) .)
	| number                               		(. exp = Number(int.Parse(t.val)) .)
	| "true"                               		(. exp = Bool(true) .)
	| "false"                              		(. exp = Bool(false) .)
	| '(' Expr<exp> ')'
	)
.

END Program.
