COMPILER Program
	
#Node
[Getter(AbstractSyntaxTree)]
_ast as WhileTree

def ExpectBool(exp as Expression, t as Token, isRightHandSide as bool):
	if not exp isa BoolExpression:
		if isRightHandSide:
			errors.SemErr(t.line, t.col, "'${t.val}' expects a boolean expression on its right side!")
		else:
			errors.SemErr(t.line, t.col, "'${t.val}' expects a boolean expression on its left side!")
		return false
	return true
		
def ExpectInt(exp as Expression, t as Token, isRightHandSide as bool):
	if not exp isa IntExpression:
		if isRightHandSide:
			errors.SemErr(t.line, t.col, "'${t.val}' expects a integer expression on its right side!")
		else:
			errors.SemErr(t.line, t.col, "'${t.val}' expects a integer expression on its left side!")
		return false
	return true


CHARACTERS
  letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
  digit = "0123456789".
  cr  = '\r'.
  lf  = '\n'.
  tab = '\t'.

TOKENS
  ident  = letter {letter | digit}.
  number = digit {digit}.

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf
COMMENTS FROM "#" TO lf

IGNORE cr + lf + tab

PRODUCTIONS

Program<>
=                                          			(.	statements as StatementSequence.)
    StmtSeq<statements>								(.	_ast = WhileTree(statements) .)
.

StmtSeq<ref statements as StatementSequence>  
=													(. 	stmt as Statement 
														slist = List[of Statement]().)
    Stmt<stmt>                         				(. slist.Add(stmt) .)
    {
        ';' Stmt<stmt>                 				(. slist.Add(stmt) .)
    }                                      			(. statements = StatementSequence(slist) .)
.

Stmt<ref stmt as Statement>                   
=													(. exp as Expression .)
	( AssignStmt<stmt>
	| "skip"                               			(. stmt = Skip() .)
	| BlockStmt<stmt>                       
	| IfStmt<stmt>
	| WhileStmt<stmt>
	| "read" ident                         			(. stmt = Read(Variable(t.val)) .)
	| "write" Expr<exp>                				(. stmt = Write(exp) .)
	)
.

VarDecStmt<ref vars as VariableDeclarationSequence>
=													(. list = List[of VariableDeclaration]() .)
	VarDec<list>
	{
	    VarDec<list>
	}												(. vars = VariableDeclarationSequence(list) .)
.

VarDec<list as List[of VariableDeclaration]>
=
	"var" ident                             		(. 	if VariableStack.IsDeclaredInCurrentScope(t.val):
															errors.SemErr(t.line, t.col, "Variable '${t.val}' is already declared in this scope!") 
														elif VariableStack.IsInScope(t.val):
															errors.Warning(t.line, t.col, "Variable '${t.val}' hides variable with same name in outer block!")
															VariableStack.DefineVariable(t.val, true)
														else:
															VariableStack.DefineVariable(t.val, true) 
														list.Add(VariableDeclaration(Variable(t.val))) .)
	';'
.

BlockStmt<ref block as Statement>                 
=
	"begin"                                 		(. 	vars as VariableDeclarationSequence
														VariableStack.PushScope() .)
	[ VarDecStmt<vars> ]							(. statements as StatementSequence .)
	StmtSeq<statements>                
	"end"                       					(. 	block = Block(vars, statements) 
														VariableStack.PopScope() .)
.

AssignStmt<ref assign as Statement>            		(. 	exp as Expression 
														var as Variable .)
=	ident                                  			(. 	var = Variable(t.val) 
														if not VariableStack.IsInScope(t.val):
															errors.SemErr(t.line, t.col, "Assignment to undeclared variable '${t.val}'") .)
	":="											(. tok = t .)
	Expr<exp>                          				(. return unless ExpectInt(exp, tok, true) .)
													(. assign = Assign(var, exp) .)
.

IfStmt<ref ifStmt as Statement>           			(. 	ifBranch as StatementSequence; 
														elseBranch as StatementSequence
														exp as Expression .)
=
	"if"											(.  tok = t .)
	Expr<exp>										(.	return unless ExpectBool(exp, tok, true) .)
	"then"
	StmtSeq<ifBranch>
	[
	    "else"
	    StmtSeq<elseBranch>
	]
	"fi"                                  			(. ifStmt = If(exp, ifBranch, elseBranch) .) 
.

WhileStmt<ref whileStmt as Statement>          		(.	exp as Expression
														whileBranch as StatementSequence .)
=
	"while"											(. tok = t .)
	Expr<exp>										(. return unless ExpectBool(exp, tok, true) .)
	"do"
	StmtSeq<whileBranch>
	"od"                                   			(. whileStmt = While(exp, whileBranch) .)
.

Expr<ref exp as Expression>
=	
    LogicOr<exp>                      
.


LogicOr<ref exp as Expression>                	(. second as Expression .)
=	
    LogicAnd<exp>                      
    {
        "or"          							(. tok = t .)
        LogicAnd<second>						(.	return unless ExpectBool(exp, tok, false) 
													return unless ExpectBool(second, tok, true) 
													exp = LogicBinaryOp(exp, second, LogicBinaryOp.Or) .)
    }                                       
.

LogicAnd<ref exp as Expression>                	(. second as Expression .)                
=	
    Comparison<exp>
    {                            
        "and"                    				(. 	tok = t .)
        Comparison<second>						(.	return unless ExpectBool(exp, tok, false) 
													return unless ExpectBool(second, tok, true) 
													exp = LogicBinaryOp(exp, second, LogicBinaryOp.And) .)
    }
.

Comparison<ref exp as Expression>           	(.	second as Expression 
													op as string .)
=
    BitOr<exp>
    [
        (
        "<"                            			(.	op = ComparisonBinaryOp.LessThan .)
        |
        ">"                                		(.	op = ComparisonBinaryOp.GreaterThan .)
        |
        "<="                               		(.	op = ComparisonBinaryOp.LessThanOrEqual .)
        |
        ">="                               		(.	op = ComparisonBinaryOp.GreaterThanOrEqual .)
		|
        "=="                               		(.	op = ComparisonBinaryOp.Equal.)
        |
        "!="                               		(.	op = ComparisonBinaryOp.NotEqual .)
        
        )										(. 	tok = t .)
        Comparison<second>						(.	return unless ExpectInt(exp, tok, false) 
													return unless ExpectInt(second, tok, true) 
													exp = ComparisonBinaryOp(exp, second, op) .)
    ]
.

BitOr<ref exp as Expression>                	(.	second as Expression .)                  
=	
    BitXor<exp>
    {
        "|"       								(. 	tok = t .)
        BitXor<second>                 			(.	return unless ExpectInt(exp, tok, false) 
													return unless ExpectInt(second, tok, true) 
													exp = BitBinaryOp(exp, second, BitBinaryOp.Or) .)
    }
.

BitXor<ref exp as Expression>                	(.	second as Expression .)                 
=	
    BitAnd<exp>
    {
        "^"     								(.	tok = t .)
        BitAnd<second>                 			(.	return unless ExpectInt(exp, tok, false) 
													return unless ExpectInt(second, tok, true) 
													exp = BitBinaryOp(exp, second, BitBinaryOp.Xor) .)
    }
.

BitAnd<ref exp as Expression>                	(.	second as Expression .)                 
=	
    BitShift<exp>
    {
        "&"                             		(. 	tok = t .)
        BitShift<second>                  		(.	return unless ExpectInt(exp, tok, false) 
													return unless ExpectInt(second, tok, true) 
													exp = BitBinaryOp(exp, second, BitBinaryOp.And) .)
    }
.

BitShift<ref exp as Expression>                	(.	second as Expression
													op as string .)               
=	
    PlusMinus<exp>
    {
        (
        "<<"                               		(.	op = BitBinaryOp.ShiftLeft .)
        |
        ">>"                               		(.	op = BitBinaryOp.ShiftRight .)
        )             							(. 	tok = t .)
        PlusMinus<second>              			(.	return unless ExpectInt(exp, tok, false) 
													return unless ExpectInt(second, tok, true) 
													exp = BitBinaryOp(exp, second, op).)
    }
.

PlusMinus<ref exp as Expression>                (. 	second as Expression 
													op as string.)              
=	
    MulDivMod<exp>
    {
        (
        "+"                                		(. 	op = ArithmeticBinaryOp.Plus .)
        |
        "-"                                		(. 	op = ArithmeticBinaryOp.Minus .)
        )             							(. 	tok = t .)
        MulDivMod<second>              			(.	return unless ExpectInt(exp, tok, false) 
													return unless ExpectInt(second, tok, true) 
													exp = ArithmeticBinaryOp(exp, second, op) .)
    }
.

MulDivMod<ref exp as Expression>                (. second as Expression .)              
=	
    UnaryOperator<exp>
    {
        (
        "*"                                		(. 	op = ArithmeticBinaryOp.Multiplication .)
        |
        "/"                                		(. 	op = ArithmeticBinaryOp.Division .)
        |
        "%"                                		(. 	op = ArithmeticBinaryOp.Modulo .)
        )             							(. 	tok = t .)
        UnaryOperator<second>          			(.	return unless ExpectInt(exp, tok, false) 
													return unless ExpectInt(second, tok, true) 
													exp = ArithmeticBinaryOp(exp, second, op) .)
    }
.


UnaryOperator<ref exp as Expression>          	(.	op as string = null .)
=                               
	[
	'-'                                    		(. 	op = t.val .)
	|
	'~'                                    		(. 	op = t.val .)
	|
	"not"                                  		(. 	op = t.val .)
												(.	tok = t .)
	]
	Terminal<exp>                      			(.	if op in ('-','~'): 
														return unless ExpectInt(exp, tok, true)
														exp = IntUnaryOp(exp, op)
													elif op == 'not':
														return unless ExpectBool(exp, tok, true)
														exp = NotUnaryOp(exp) .)
.

Terminal<ref exp as Expression>               
=
	( ident                                		(. 	exp = Variable(t.val) 
													if not VariableStack.IsInScope(t.val):
														errors.SemErr(t.line, t.col, "Undeclared variable '${t.val}'") .)
	| number                               		(. exp = Number(int.Parse(t.val)) .)
	| "true"                               		(. exp = Bool(true) .)
	| "false"                              		(. exp = Bool(false) .)
	| '(' Expr<exp> ')'
	)
.

END Program.
