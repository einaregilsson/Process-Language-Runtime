/**
 * $Id$ 
 * 
 * This file is part of the Process Language Runtime (PLR) 
 * and is licensed under the GPL v3.0.
 * 
 * Author: Einar Egilsson (einar@einaregilsson.com) 
 */
 /*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
----------------------------------------------------------------------*/
using System;
using System.Collections.Generic;
using PLR.Analysis;

namespace KLAIM.Parsing {

    public partial class Parser {

        const bool T = true;
        const bool x = false;
        const int minErrDist = 2;

        public Scanner scanner;
        public Errors errors;

        public Token t;    // last recognized token
        public Token la;   // lookahead token
        int errDist = minErrDist;

        public Parser(Scanner scanner) {
            this.scanner = scanner;
            errors = new Errors();
        }

        private ProcessSystem processes = new ProcessSystem();
        public ProcessSystem Processes { get { return this.processes; } }

        private List<TupleInfo> tuples = new List<TupleInfo>();
        public List<TupleInfo> LocatedTuples { get { return this.tuples; } }

        private Dictionary<string, int> procNames = new Dictionary<string, int>();
        
        private string GetProcName(string locality) {
            if (!procNames.ContainsKey(locality)) {
                procNames.Add(locality, 0);
            }
            procNames[locality] += 1;
            return locality + procNames[locality];
        }

        private void SetPos(Node n, Token t) {
            n.LexicalInfo.StartLine = t.line;
            n.LexicalInfo.StartColumn = t.col;
            n.LexicalInfo.EndLine = t.line;
            n.LexicalInfo.EndColumn = t.col + t.val.Length;
        }

        private void SetPos(Node n, Token start, Token end) {
            n.LexicalInfo.StartLine = start.line;
            n.LexicalInfo.StartColumn = start.col;
            n.LexicalInfo.EndLine = end.line;
            n.LexicalInfo.EndColumn = end.col + end.val.Length;
        }

        private void SetStartPos(Node n, Token t) {
            n.LexicalInfo.StartLine = t.line;
            n.LexicalInfo.StartColumn = t.col;
        }

        private void SetEndPos(Node n, Token t) {
            n.LexicalInfo.EndLine = t.line;
            n.LexicalInfo.EndColumn = t.col;
        }

        private void CopyPos(Node n, Node source, Token end) {
            n.LexicalInfo.StartLine = source.LexicalInfo.StartLine;
            n.LexicalInfo.StartColumn = source.LexicalInfo.StartColumn;
            n.LexicalInfo.EndLine = t.line;
            n.LexicalInfo.EndColumn = t.col;
        }

        void SynErr(int n) {
            if (errDist >= minErrDist) errors.SynErr(la.line, la.col, n);
            errDist = 0;
        }

        public void SemErr(string msg) {
            if (errDist >= minErrDist) errors.SemErr(t.line, t.col, msg);
            errDist = 0;
        }

        void Expect(int n) {
            if (la.kind == n) Get(); else { SynErr(n); }
        }

        bool StartOf(int s) {
            return set[s, la.kind];
        }

        void ExpectWeak(int n, int follow) {
            if (la.kind == n) Get();
            else {
                SynErr(n);
                while (!StartOf(follow)) Get();
            }
        }


        bool WeakSeparator(int n, int syFol, int repFol) {
            int kind = la.kind;
            if (kind == n) { Get(); return true; } else if (StartOf(repFol)) { return false; } else {
                SynErr(n);
                while (!(set[syFol, kind] || set[repFol, kind] || set[0, kind])) {
                    Get();
                    kind = la.kind;
                }
                return StartOf(syFol);
            }
        }
    } // end Parser


    public partial class Errors {
        public int count = 0;                                    // number of errors detected
        public System.IO.TextWriter errorStream = Console.Out;   // error messages go to this stream
        public string errMsgFormat = "-- line {0} col {1}: {2}"; // 0=line, 1=column, 2=text

        public void SynErr(int line, int col, int n) {
            string s;
            s = GetErrorMessage(n);
            if (s == null) {
                s = "error " + n;
            }
            errorStream.WriteLine(errMsgFormat, line, col, s);
            count++;
        }

        public void SemErr(int line, int col, string s) {
            errorStream.WriteLine(errMsgFormat, line, col, s);
            count++;
        }

        public void SemErr(string s) {
            errorStream.WriteLine(s);
            count++;
        }

        public void Warning(int line, int col, string s) {
            errorStream.WriteLine(errMsgFormat, line, col, s);
        }

        public void Warning(string s) {
            errorStream.WriteLine(s);
        }
    } // Errors


    public class FatalError : Exception {
        public FatalError(string m) : base(m) { }
    }
}