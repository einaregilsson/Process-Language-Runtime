\chapter{CCS Implementation}

In this chapter we look at the Calculus of Communicating System process language, its history, formal syntax and semantics, and its implementation with the PLR as the back end compiler. CCS was the first language implemented using the PLR, and it was implemented at the same time as the PLR was being designed. For that reason the PLR contains all the main constructs of CCS so that the CCS specific parts of the implementation are fairly small and mostly have to do with the front end, that is the lexer and parser. A description of a another language, one that extends the PLR further, is found in Chapter~\ref{ch:klaim}.

\section{History}

\section{Formal syntax and semantics}\label{sec:ccs_syntax}

The collection $P$ of CCS expressions is given by the following grammar

\begin{math}
	P,Q ::= K \bigm\vert \alpha.P \bigm\vert \sum_{i \in I} P_i \bigm\vert P \mid Q \bigm\vert P[f] \bigm\vert P\ \backslash\ L
\end{math}

where

\begin{itemize}
	\item $K$ is a process name in $\mathcal{K}$,
	\item $\alpha$ is an action in \textsf{Act},
	\item $I$ is a possibly infinite index set,
	\item $f$ : \textsf{Act} $\rightarrow$ \textsf{Act} is a \textit{relabelling function} satisfying the constraints
	
	\begin{tabular{r c l}
	f(\tau) & = & \tau, \\
	f(\overline{a})& = & \overline{f(a)} for each label a, \\
	\end {tabular}
	\item $L$ is a set of labels from $\mathcal{L}$
	\begin{math}
	
	\end{math}
	
\end{itemize}

\section{Value passing syntax and semantics}\label{ccs_value_syntax}

\section{Implementation}

	The CCS implementation was written in C\# using Visual Studio 2008 as the 
	development environment. Since the PLR includes abstract syntax tree nodes 
	for all constructs of CCS, no additional nodes were created specifically for 
	the CCS implementation. There are only a handful of classes used, below is a 
	short summary of each one.

	\begin{itemize}
	
	\item \textsf{Program} is the entry point into the compiler. It contains a 
	\textsf{Main} method that parses command line parameters, validates 
	parameters such as input and output file names and then creates a 
	\textsf{Parser} object. It then calls the parser's \textsf{Parse} method, 
	receives a PLR \textsf{ProcessSystem} node and calls \textsf{Compile} on it. 
	
	\item \textsf{Scanner} is the lexer class whose responsibility it is to tokenize a CCS source code file into valid CCS terminals. Listing~\ref{lst:ccsterminals} shows the more complicated terminals of CCS defined by regular expressions. The simpler terminals, who are just string constants, are given directly in quotes in the parser definition.
	
  \item \textsf{Parser} is a recursive-descent parser for CCS. It uses the 
  tokens generated by \textsf{Scanner} and applies a number of 
  \textsf{productions} to recognize the language. The Extended Backus-Naur 
  Form (EBNF) of the productions is given in Listing~\ref{lst:ccs_ebnf}. The 
  parser constructs a PLR abstract syntax tree as it parses, if the parsing is 
  without errors the syntax tree can then be compiled. Both the 
  \textsf{Parser} and \textsf{Scanner} are generated by the parser generator 
  Coco/R \cite{cocor}. It takes as input a EBNF specification of the language 
  interspersed with C\# source code and from that it generates the 
  \textsf{Scanner} and \textsf{Parser} classes. 
	
	\item \textsf{ParserTest} contains unit tests for the parser and scanner, to 
	be run with the NUnit unit testing framework.
	
	\end{itemize}
	\begin{figure}
\lstset{showtabs=false,showspaces=false,showstringspaces=false}
\begin{lstlisting}[caption=Terminals of CCS scanner,label=lst:ccsterminals,frame=trbl,basicstyle=\scriptsize\ttfamily,showtabs=false,showspaces=false]
  PROCNAME   = [A-Z][A-Za-z0-9]*
  LCASEIDENT = [a-z][A-Za-z0-9]*
  CLASSNAME  = [A-Z][A-Za-z0-9]*(\\.[A-Z][A-Za-z0-9]*)*
  OUTACTION  = _[a-z][A-Za-z0-9]*_
  METHOD     = :[a-zA-Z][A-Za-z0-9]*
  NUMBER     = [0-9]+
  STRING     = "[^"]*"'
  \end{lstlisting}
	\end{figure}
	
	\begin{figure}
\lstset{showtabs=false,showspaces=false,showstringspaces=false}
\begin{lstlisting}[caption=EBNF Productions of CCS parser,frame=trbl,label=lst:ccs_ebnf,basicstyle=\scriptsize\ttfamily,showtabs=false,showspaces=false]
CCS = { ClassImport } ProcessDefinition { ProcessDefinition } 

ClassImport = "use" CLASSNAME 

ProcessDefinition = 
  PROCNAME [ "(" LCASEIDENT {"," LCASEIDENT } ")" ] "=" Process 

Process = NonDeterministicChoice

NonDeterministicChoice = ParallelComposition { "+" ParallelComposition }

ParallelComposition = ActionPrefix { "|" ActionPrefix } .

ActionPrefix =
  { Action "." }
  (
    "(" Process ")"
    | "0"
    | ProcessConstantInvoke
    | BranchProcess
  )
  [ Relabelling ]
  [ Restriction ]

BranchProcess = "if" Expression "then" Process "else" Process .

ProcessConstantInvoke = 
  PROCNAME [ "(" ArithmeticExpression {"," ArithmeticExpression } ")" ]

Action =
  LCASEIDENT [ "(" LCASEIDENT { "," LCASEIDENT } ")" ]
  | OUTACTION [ "(" ArithmeticExpression { "," ArithmeticExpression } ")" ]
  | METHOD "(" [ CallParam { "," CallParam } ")"

CallParam = ArithmeticExpression | STRING

Relabelling =
  "[" METHOD "]"
  | "[" LCASEIDENT "/" LCASEIDENT { "," LCASEIDENT "/" LCASEIDENT } "]"

Restriction = 
  "\" 
  (
    LCASEIDENT 
    | "{" LCASEIDENT {"," LCASEIDENT } "}"
    | METHOD
  )        

Expression = OrTerm { "or" OrTerm }

OrTerm = AndTerm { "and" AndTerm }

AndTerm = RelationalTerm { "xor" RelationalTerm }

RelationalTerm = 
  ArithmeticExpression [ ("=="|"!="|">"|">="|"<"|"<=") ArithmeticExpression ]
		
ArithmeticExpression = PlusMinusTerm { ("+" | "-") PlusMinusTerm }

PlusMinusTerm = UnaryMinusTerm { ("*"|"/"|"\%") UnaryMinusTerm }

UnaryMinusTerm =
  [ "-" ]                                   
  (
    "(" ArithmeticExpression ")"
    | NUMBER 
    | "0"
    | "true"
    | "false"
    | LCASEIDENT
  )
	\end{lstlisting}
	\end{figure}
	
	Section~\ref{sec:ccs_syntax} shows the formal syntax for CCS, it however does not account for integrating with the .NET environment to allow arbitrary method calls to be made as actions and .NET methods to be used as relabelling functions and/or restriction functions. The complete allowed syntax can be seen in Listing~\ref{lst:ccs_ebnf}, but to quickly summarize the changes from formal CCS, they are as follows:
	
	\begin{itemize}
		
		\item A CCS source code file can start with one or more \texttt{use} 
		statements, which consist of the token \texttt{use} followed by the fully 
		qualified name of a .NET class. This class can be in the .NET core 
		library, \texttt{mscorlib}, or in any arbitrary .NET assembly. During 
		compilation the filenames of assemblies containing classes used in the 
		source code must be passed to the compiler so that it knows where to look 
		for classnames found in \texttt{use} statements.
	
		\item Actions can be calls to .NET methods in addition to synchronization 
		and value passing on channels. A .NET method call consists of a colon 
		followed by the method name and parantheses around expressions passed as 
		parameters to the method, e.g. \texttt{:Power(2, 3*2)}. At compile time 
		the PLR resolves which class the method belongs to by looking at the 
		classes imported with \texttt{use} statements and inspecting their 
		methods. If more than one imported class has a candidate method an 
		exception is thrown.
		
		\item Relabelling functions can be specified as .NET methods in addition 
		to be constant replacements. To use a .NET method for relabelling its name 
		prefixed with a colon is put inside the square brackets that usually 
		define relabelling functions in CCS, e.g. \texttt{[:MyRelabelMethod]}. The 
		method is resolved to an imported class at compile time and is required to 
		be a method that takes a single parameter, an instance of the 
		\textsf{IAction} interface from the PLR runtime library.
		
		\item Restrctions functions can be specified as .NET methods in much the 
		same way as relabelling functions and must resolve to a method that takes 
		a \textsf{IAction} instance as a parameter. An example of a process which 
		uses a .NET method for restriction could be \texttt{(a . 0) \ :MyRestrict}.
	\end{itemize}