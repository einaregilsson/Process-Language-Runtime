\chapter{CCS Implementation}\label{ch:ccs_implementation}

	In this chapter we look at the Calculus of Communicating System process 
	language, its history, formal syntax and semantics, and its implementation 
	with the PLR as the back end compiler. 
	
\section{Overview}

	CCS was created by Robin Milner in the 1970's where it was the subject of a 
	number of papers such as \cite{milner1,milner2,milner3} and finally a book 
	of the same name \cite{Milner80} published in 1980. It is, along with CSP, 
	one of the oldest process algebras, but is still widely taught in university 
	courses about concurrent systems and is language of choice in textbooks on 
	concurrent systems such as \cite{reactive}. 
	
	In its pure form the language is fairly simple and contains fewer constructs 
	than some of the other process algebras which came after it. This makes it 
	an ideal candidate to use as the blueprint for the PLR. The PLR and the CCS 
	compiler were developed in parallel and the PLR provides all the constructs 
	that CCS needs. Because of that the actual CCS compiler itself is fairly 
	small and mostly has to do with the front end, that is the lexer and parser. 
	A description of another language implementation, one that extends the PLR 
	further, is the subject of Chapter~\ref{ch:klaim}.
	
\section{Syntax and semantics}\label{sec:ccs_syntax}

	The version of CCS defined here is equivalent to the one defined in 
	\cite{reactive}, other variants sometimes have slightly different syntax 
	(e.g. use \textsf{nil} instead of 0). The language can be described by the 
	following syntax

\begin{itemize}
		\item Let $\mathcal{A}$ be the set of \textit{channel names}, we use 
		$\alpha$ as a typical member of this set in demonstrations.
	
		\item $\overline{\mathcal{A}} := \{\overline{a}\mid a \in \mathcal{A}\}$
		denotes the set of co-names. For each channel name there is a
		corresponding co-name. Channel name represents input, co-name represents 
		output.
	
		\item Let $\mathcal{L} := \mathcal{A} \cup \overline{\mathcal{A}}$ be the 
		set of \textit{labels}.
		
		\item \textsf{Act} $:= \mathcal{L} \cup {\tau}$ is the set of 
		\textit{actions}, where $\tau$ denotes the silent (or unobservable) action.
		
		\item Let $\mathcal{K}$ be a set of process identifiers.
		
		\item The set $\mathcal{P}$ of process expressions is defined by the 
		following syntax:

		\begin{tabular}{r c l l}
			$P$ & ::= & 0 & (Nil process)\\
			    & $\mid$ & $\alpha$ . $P$ & (Action prefixing) \\
			    & $\mid$ & $K$ & (Invoking a process)\\
			    & $\mid$ & $P \mid Q$ & (Parallel composition)\\
			    & $\mid$ & $P$ + $Q$ & (Nondeterministic choice)\\
			    & $\mid$ & $P$[$f$] & (Relabelling)\\
			    & $\mid$ & $P\ \backslash\ L$ & (Restriction)
		\end{tabular}
		
		where 
		
		\begin{itemize}
			\item $P,Q$ are processes in $\mathcal{P}$
			\item $\alpha$ is an action in \textsf{Act}
			\item $K$ is a process name from $\mathcal{K}$
			\item $f$ : \textsf{Act} $\rightarrow$ \textsf{Act} is a relabelling 
			function satisfying the constraints $f(\tau) = \tau$ and 
			$f(\overline{a}) = \overline{f(a)}$ for each label \textit{a}.
			\item $L$ is a set of labels from $\mathcal{L}$
		\end{itemize} 
		
		\item We assume that the behavior of each process name $K \in \mathcal{K}$ 
		is given by a defining equation
		
		\begin{center}$K \defeq P$\end{center}
		
		where $P \in \mathcal{P}$.

	\end{itemize}
	To avoid the use of too many parantheses in writing CCS expressions 
	the convention is used that operators have decreasing binding strength in 
	the following order: restriction and relabelling (the tightest binding), 
	action prefixing, parallel composition and summation. For example, the 
	expression $a.0 \mid b.P\ \backslash\ L + c.0$ stands for
		
	\begin{center}$((a.0) \mid (b.(P\ \backslash\ L))) + (c.0)$\end{center}
		
	For an informal description of each of the constructs(action-prefixing, 
	parallel composition, non-deterministic choice, restrictino and relabelling) 
	we refer to Section~\ref{sec:common_constructs} where such a description was 
	already given. For a formal description, Table~\ref{tab:ccs_sos} shows the 
	structural operational semantics of CCS.


\begin{table}[t]
\begin{ARRAY}{c}
%%Out
	\mathrm{ACT}\ \ \ \Inference{                              }
	                            {\alpha.P \infarrow{\alpha} P} \vspace{10pt}\\
	\mathrm{SUM}_j\ \ \ \Inference{P_j \infarrow{\alpha} P_j'}
	                              {\sum_{i\in I}P_i \infarrow{\alpha} P_j'}\ \ \mathrm{where}\ j \in I\vspace{10pt}\\
	\mathrm{COM1}\ \ \ \Inference{P \infarrow{\alpha} P'}
	                             {P \mid Q \infarrow{\alpha} P' \mid Q} \vspace{10pt}\\
	\mathrm{COM2}\ \ \ \Inference{Q \infarrow{\alpha} Q'}
	                             {P \mid Q \infarrow{\alpha} P \mid Q'} \vspace{10pt}\\
	\mathrm{COM3}\ \ \ \Inference{P \infarrow{\alpha} P'\ \ \ \ Q \infarrow{\alpha} Q'}
	                             {P \mid Q \infarrow{\tau} P' \mid Q'} \vspace{10pt}\\
	\mathrm{RES}\ \ \ \Inference{P \infarrow{\alpha} P'}
	                              {P\ \backslash\ L \infarrow{\alpha} P'\  \backslash\ L}\ \ \mathrm{where}\ \alpha, \overline{\alpha} \notin L\vspace{10pt}\\
	\mathrm{REL}\ \ \ \Inference{P \infarrow{\alpha} P'}
	                             {P[f] \infarrow{f(\alpha)} P'[f]} \vspace{10pt}\\
	\mathrm{CON}\ \ \ \Inference{P \infarrow{\alpha} P'}
	                             {K \infarrow{\alpha} P'}\ \ \mathrm{where}\ K \defeq P

\end{ARRAY}
\caption{CCS structural operational semantics}
\label{tab:ccs_sos}
\end{table}

\section{Value passing CCS}\label{ccs_value_syntax}
	
	The syntax and semantics given in Section~\ref{sec:ccs_syntax} above are 
	those for so-called \textit{pure} CCS, in which communication is pure 
	synchronization and involves no exchange of data. A more practical approach 
	would be to allow processes to send and receive data when communicating on 
	channels, this is a great convenience when modelling certain types of 
	processes. R. Milner, the originator of CCS introduced an extension to CCS 
	in \cite{milner89}, \textit{value-passing CCS}. In the same book he proved 
	that while the extension was convenient, it was theoretically unnecessary. 
	Value-passing CCS introduced three main things which contribute to 
	efficently modelling systems that handle data.
	
	\begin{enumerate}
		\item Data can be sent and received through channels during 
		synchronization. On the receiving end the data is bound to a variable 
		name. Below we see the value 5 being passed from process $Q$ to process 
		$P$ through the channel \textit{a}.

		\begin{Exa}
			\begin{align*}
				\mathrm{P} \defeq & a(x) \ccsdot 0 \\
				\mathrm{Q} \defeq & \out{a(5)} \ccsdot 0 
			\end{align*}	
		\end{Exa}
		
	 	The output action can contain variable names, constant values or  
	 	arithmetic expressions, e.g. $\overline{a(x+y/4)}$. The input action can 
	 	only contain variable names to bind to the incoming value(s).
		
		\item Process constants can be parameterized. When a process turns into a 
		parameterized process, it passes a value to that process, which in turn 
		binds the value to the variables specified in the process definition. 
		Example~\ref{ex:ccs_parameterized_pc} shows a process $P$ that syncs on 
		channel \textit{a}, then turns into process $Q$ and passes it the value 4. 
		When process $Q$ starts it has the value 4 bound to the name $x$ and tries 
		to pass that to some other process through the $b$ channel.

		\begin{Exa}
			\label{ex:ccs_parameterized_pc}
			\begin{align*}
				\mathrm{P} \defeq & a \ccsdot \mathrm{Q(4)} \\
				\mathrm{Q(x)} \defeq & \out{b(x)} \ccsdot 0 
			\end{align*}	
		\end{Exa}
		
		\item A conditional expressions is introduced into the language. It takes 
		the form \textbf{if} bexp \textbf{then} $P$ \textbf{else} $Q$. 
		Example~\ref{ex:ccs_if} shows a process $P$ which checks whether the value 
		of variable $x$ is less than 2, if so it turns into process $Q$, otherwise 
		it turns into the nil process and terminates.

		\begin{Exa}
			\label{ex:ccs_if}
			\begin{align*}
				\mathrm{P(x)} \defeq \mathbf{if}\ x < 2\ \mathbf{then}\ Q\  \mathbf{else}\ 0 
			\end{align*}	
		\end{Exa}
	\end{enumerate}
	
	The structural operational semantics for these additions to the language are given in Table~\ref{tab:ccs_value_pass_sos}.	

\begin{table}[t]
	\begin{ARRAY}{c}
		\mathrm{INP}\ \ \ \Inference{                              }
	                            {a(x).P \infarrow{a(n)} P[n/x]} \vspace{10pt}\\
	\mathrm{OUTP}\ \ \ \Inference{                              }
	                            {\overline{a}(e).P \infarrow{\overline{a(n)}} P}\ \ n \mathrm{\ \ is\ the\ result\ of\ evaluating}\ e. \vspace{10pt}\\
		\mathrm{COND1}\ \ \ \Inference{P \infarrow{\alpha} P'}
	                            {\mathbf{if}\ bexp\ \mathbf{then}\ P\  \mathbf{else}\ Q \infarrow{\alpha} P'}\ \ \mathrm{bexp\ is\ true} \vspace{10pt}\\
		\mathrm{COND2}\ \ \ \Inference{Q \infarrow{\alpha} Q'}
	                            {\mathbf{if}\ bexp\ \mathbf{then}\ P\  \mathbf{else}\ Q \infarrow{\alpha} Q'}\ \ \mathrm{bexp\ is\ false} \vspace{10pt}\\

		\mathrm{PCONST}\ \ \ \Inference{P[v_1/x_1,...,v_n/x_n] \infarrow{\alpha} P'}
	 {\mathrm{A}(e_1,...,e_n)\infarrow{\alpha}P'}\ \mathrm{A}(x_1,...,x_n) \defeq P\ \mathrm{and\ each}\ e_i\ \mathrm{has\ value}\ v_i\vspace{10pt}\\
	                            
	\end{ARRAY}
	\caption{Value-passing CCS structural operational semantics}
	\label{tab:ccs_value_pass_sos}
\end{table}


\section{Implementation}

	The CCS implementation was written in C\# using Visual Studio 2008 as the 
	development environment. It implements both pure and value-passing CCS, it 
	is allowed but not necessary to pass values when synchronizing on channels. 
	Since the PLR includes abstract syntax tree nodes for all constructs of CCS, 
	no additional nodes were created specifically for the CCS implementation. 
	There are only a handful of classes used, below is a short summary of each 
	one.

\subsection{Class overview}\label{ccs_class_overview}
	\begin{itemize}
	
	\item \textsf{Program} is the entry point into the compiler. It contains a 
	\textsf{Main} method that parses command line parameters, validates 
	parameters such as input and output file names and then creates a 
	\textsf{Parser} object. It then calls the parser's \textsf{Parse} method, 
	receives a PLR \textsf{ProcessSystem} node and calls \textsf{Compile} on it. 
	
	\item \textsf{Scanner} is the lexer class whose responsibility it is to 
	tokenize a CCS source code file into valid CCS terminals. 
	Listing~\ref{lst:ccsterminals} shows the more complicated terminals of CCS 
	defined by regular expressions. The simpler terminals, who are just string 
	constants, are given directly in quotes in the parser definition. The 
	scanner is implemented as a finite state automaton.
	
  \item \textsf{Parser} is a recursive-descent parser for CCS. It uses the 
  tokens generated by \textsf{Scanner} and applies a number of 
  \textsf{productions} to recognize the language. The Extended Backus-Naur 
  Form (EBNF) of the productions is given in Listing~\ref{lst:ccs_ebnf}. The 
  parser constructs a PLR abstract syntax tree as it parses, if the parsing is 
  without errors the syntax tree can then be compiled. Both the 
  \textsf{Parser} and \textsf{Scanner} are generated by the parser generator 
  Coco/R \cite{cocor}. It takes as input an EBNF specification of the language 
  interspersed with C\# source code and from that it generates the 
  \textsf{Scanner} and \textsf{Parser} classes. 
	
	\item \textsf{ParserTest} contains unit tests for the parser and scanner, to 
	be run with the NUnit unit testing framework.
	
	\end{itemize}
	\begin{figure}
\lstset{showtabs=false,showspaces=false,showstringspaces=false}
\begin{lstlisting}[caption=Terminals of CCS scanner,label=lst:ccsterminals,frame=trbl,basicstyle=\scriptsize\ttfamily,showtabs=false,showspaces=false]
  PROCNAME   = [A-Z][A-Za-z0-9]*
  LCASEIDENT = [a-z][A-Za-z0-9]*
  CLASSNAME  = [A-Z][A-Za-z0-9]*(\\.[A-Z][A-Za-z0-9]*)*
  OUTACTION  = _[a-z][A-Za-z0-9]*_
  METHOD     = :[a-zA-Z][A-Za-z0-9]*
  NUMBER     = [0-9]+
  STRING     = "[^"]*"'
  \end{lstlisting}
	\end{figure}
	
	\begin{figure}
\lstset{showtabs=false,showspaces=false,showstringspaces=false}
\begin{lstlisting}[caption=EBNF Productions of CCS parser,frame=trbl,label=lst:ccs_ebnf,basicstyle=\scriptsize\ttfamily,showtabs=false,showspaces=false]
CCS = { ClassImport } ProcessDefinition { ProcessDefinition } 

ClassImport = "use" CLASSNAME 

ProcessDefinition = 
  PROCNAME [ "(" LCASEIDENT {"," LCASEIDENT } ")" ] "=" Process 

Process = NonDeterministicChoice

NonDeterministicChoice = ParallelComposition { "+" ParallelComposition }

ParallelComposition = ActionPrefix { "|" ActionPrefix } .

ActionPrefix =
  { Action "." }
  (
    "(" Process ")"
    | "0"
    | ProcessConstantInvoke
    | BranchProcess
  )
  [ Relabelling ]
  [ Restriction ]

BranchProcess = "if" Expression "then" Process "else" Process .

ProcessConstantInvoke = 
  PROCNAME [ "(" ArithmeticExpression {"," ArithmeticExpression } ")" ]

Action =
  LCASEIDENT [ "(" LCASEIDENT { "," LCASEIDENT } ")" ]
  | OUTACTION [ "(" ArithmeticExpression { "," ArithmeticExpression } ")" ]
  | METHOD "(" [ CallParam { "," CallParam } ")"

CallParam = ArithmeticExpression | STRING

Relabelling =
  "[" METHOD "]"
  | "[" LCASEIDENT "/" LCASEIDENT { "," LCASEIDENT "/" LCASEIDENT } "]"

Restriction = 
  "\" 
  (
    LCASEIDENT 
    | "{" LCASEIDENT {"," LCASEIDENT } "}"
    | METHOD
  )        

Expression = OrTerm { "or" OrTerm }

OrTerm = AndTerm { "and" AndTerm }

AndTerm = RelationalTerm { "xor" RelationalTerm }

RelationalTerm = 
  ArithmeticExpression [ ("=="|"!="|">"|">="|"<"|"<=") ArithmeticExpression ]
		
ArithmeticExpression = PlusMinusTerm { ("+" | "-") PlusMinusTerm }

PlusMinusTerm = UnaryMinusTerm { ("*"|"/"|"\%") UnaryMinusTerm }

UnaryMinusTerm =
  [ "-" ]                                   
  (
    "(" ArithmeticExpression ")"
    | NUMBER 
    | "0"
    | "true"
    | "false"
    | LCASEIDENT
  )
	\end{lstlisting}
	\end{figure}
	
\subsection{Extensions to CCS syntax}

	Section~\ref{sec:ccs_syntax} shows the formal syntax for CCS, it however 
	does not account for integrating with the .NET environment to allow 
	arbitrary method calls to be made as actions and .NET methods to be used as 
	relabelling functions and/or restriction functions. The EBNF specification 
	for the parser which shows all allowed syntax can be seen in 
	Listing~\ref{lst:ccs_ebnf}, but to quickly summarize the changes from formal 
	CCS, they are as follows:
	
	\begin{itemize}
		
		\item A CCS source code file can start with one or more \texttt{use} 
		statements, which consist of the token \texttt{use} followed by the fully 
		qualified name of a .NET class. E.g.
		
		\begin{center}\texttt{use System.Console\ \ \ \ \ \ \ \ \ \ \ \ \\\texttt{use MyCustomNamespace.MyClass}}\end{center}
		
		These referenced classes can be in the .NET core library, 
		\texttt{mscorlib}, or in any arbitrary .NET assembly. During compilation 
		the filenames of assemblies containing classes used in the source code 
		must be passed to the compiler so that it knows where to look for 
		classnames found in \texttt{use} statements.
	
		\item Actions can be calls to .NET methods in addition to synchronization 
		and value passing on channels. A .NET method call consists of a colon 
		followed by the method name and parantheses around expressions passed as 
		parameters to the method, e.g. 
		
		\begin{center}\texttt{P = :Print(``Hello world'') . 0}\end{center}
		
		At compile time the PLR resolves which class the method belongs to by 
		looking at the classes imported with \texttt{use} statements and 
		inspecting their methods. If more than one imported class has a candidate 
		method an exception is thrown. The methods must be static, if instance 
		methods are to be used it is necessary to write a static wrapper method 
		around them that creates an instance of the object in question and calls 
		the instance method.
		
		\item Relabelling functions can be specified as .NET methods in addition 
		to be constant replacements. To use a .NET method for relabelling its name 
		prefixed with a colon is put inside the square brackets that usually 
		define relabelling functions in CCS, e.g. \texttt{[:MyRelabelMethod]}. The 
		method is resolved to an imported class at compile time and is required to 
		be a method that takes a single parameter, an instance of the 
		\textsf{IAction} interface from the PLR runtime library.
		
		\item Restrictions functions can be specified as .NET methods in much the 
		same way as relabelling functions and must resolve to a method that takes 
		a \textsf{IAction} instance as a parameter. An example of a process which 
		uses a .NET method for restriction could be \texttt{(a . 0) \ :MyRestrict}.

	\end{itemize}
	
\section{Summary}
	
	The CCS compiler is a fully working command line tool which supports both 
	\textit{pure} and \textit{value-passing} CCS. In this chapter we looked at 
	the CCS language itself, its syntax, semantics and value-passing extensions, 
	and finally the implementation details of the compiler and how it interacts 
	with the PLR.	More practical aspects of the CCS compiler (command line 
	parameters, where to download, license etc.) can be found in Appendix A and 
	Chapter~\ref{ch:ide} describes how the compiler can be fully integrated into 
	an integrated development environment.