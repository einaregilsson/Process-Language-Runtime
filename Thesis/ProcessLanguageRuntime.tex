\chapter{Process Language Runtime}

	This chapter presents the design and implementation of the Process Language 
	Runtime, an extensible compiler backend and a runtime library for running 	
	process languages on the .NET platform. 

\section{Inspiration}

	The inspiration for the Process Language Runtime comes from the Dynamic 
	Language Runtime \TODO{NEED REF} (DLR), a framework from Microsoft for 	
	developing dynamic languages on top of the Common Language Runtime. Since 
	the .NET Common Intermediate Language is statically typed it is ill-suited
	for dynamic languages such as Python, Ruby or JavaScript. To clarify, 
	statically typed languages are languages where the type of a variable is 
	known at compile time and the type of a variable never changes, while in a 
	dynamically typed language a single variable can contain objects of 	
	different types at different times during program execution. The idea of 
	having a common abstract syntax tree for different languages comes from the 
	DLR. However, the DLR was not directly used for this project since its 
	abstract syntax tree is mainly concerned with traditional constructs for 
	imperative programming languages and constructs to support dynamic typing, 
	while the purpose of this project is to provide constructs common to process 
	languages, and dynamic typing is not an issue we are concerned with.

\section{Overview}

	The PLR is a single .NET assembly, named PLR.dll. This assembly contains the 
	abstract syntax tree and associated helper objects as well as all the 
	classes used at runtime. The PLR does not contain any lexer or parser and 
	generally has no notion of any concrete syntax. Creating a lexer and parser 
	is the responsibility of individual language implementations, the PLR takes 
	over once an input file has been parsed and used to construct a PLR abstract 
	syntax tree. 
	
	It is important to note that the PLR does not, nor is it meant 
	to, support all constructs of all process languages. Creating a superset of 
	all existing process languages has never been the goal, instead the goal is 
	to provide a common subset of the most common constructs found in these 
	languages and to make it easy to extend with specific new constructs needed 
	for specific languages. To enable this, the classes and interfaces in the 
	PLR have been engineered to make them easy to subclass and implement.
	
	As the PLR contains classes needed at runtime it must be distributed with 
	any compiled process language application. However, an option is present in 
	the compilation stage that allows the PLR assembly to be embedded in the 
	final compiled executable program, and can optionally embed any additional 
	runtime libraries that specific languages require. This allows a process 
	language program to be distributed as a single file without any external 
	dependencies other than the .NET framework itself.

	The PLR itself is written in the C\# programming language using Visual 
	Studio 2008 as the development environment. It has a dependency on the NUnit 
	unit test framework, however this dependency is only needed when running 
	internal unit tests and so does not need to be distributed with the PLR 
	assembly. The source code for the PLR is licensed under the General Public 
	License (GPL) v3.0.
	
\section{Abstract Syntax Tree}

	The PLR abstract syntax tree is the component that generates CIL 
	bytecode to run a process language application. Once an abstract syntax tree 
	has been constructed, a call to a \method{Compile} method on the tree's root 
	node with the appropriate parameters will create an executable .NET 
	assembly. 

\subsection{Architecture}

	The architecture of the abstract syntax tree is based on Object Oriented 
	principles, namely that an object contains data and methods to operate on 
	that data. As such, each node in the abstract syntax tree knows how to 
	compile itself, there is no compiler class, the whole syntax tree is the 
	compiler. Every node in the syntax tree inherits from an abstract 
	\textsf{Node} base class which has an abstract \textsf{Compile} 
	method. Concrete node classes override the \method{Compile} method and in it 
	emit the appropriate byte codes for the language construct that the node 
	represents. 
	
	The compilation itself is recursive, calling the \method{Compile} method 
	on the root node of the tree will cause it to call the \method{Compile} 
	method of its child nodes, who in turn call \method{Compile} on their child 
	nodes and thus the compilation propagates throughout the entire tree. The 
	reason for choosing this architecture was to make the syntax tree easily 
	extendable by language implementors, who can add new nodes to represent new 
	constructs. 
	
	Concrete nodes typically do not inherit directly from the \textsf{Node} base 
	class, instead they inherit from one of five intermediate classes, 
	\textsf{Action}, \textsf{Process}, \textsf{Expression}, 
	\textsf{ActionRestrictions} or \textsf{PreProcessActions}. Below is a short 
	overview of what each of these classes represents.
	
	\textbf{Action} represents an action taken by the 
	process. This can for instance be sending on a channel, receiving on a 
	channel or calling an arbitrary method. Concrete descendants of this class 
	typically have either no child nodes of their own, or a list of 
	\textsf{Expression} nodes, representing parameters to a method call or 
	values passed through a channel.

	\textbf{Process} is the base class for processes. Its descendants include an 
	\textsf{ActionPrefix} class, a \textsf{NonDeterministicChoice} class and a 
	\textsf{ParallelComposition} class. Implementing a new language construct 
	such as replication could be done be creating a new descendant of this 
	class. Child nodes of \textsf{Process} classes vary, the 
	\textsf{ActionPrefix} class for example has one \textsf{Action} child node 
	representing the action about to be performed and one \textsf{Process} child 
	node representing the process that the current process turns into after 
	performing the action. Processes that are a composition of other processes 
	such as \textsf{ParallelComposition} and \textsf{NonDeterministicChoice} 
	have a list of other \textsf{Process} instances as childnodes.
	
	\textbf{Expression} represents an expression such as an arithmetic 
	expression, numeric or string constant, a method call or the value of a 
	variable.	Expressions compile in such a way that once they have been 
	evaluated a single value, the result of the expression, is at the top of the 
	evaluation stack. This means that a node that has an expression as a child 
	node can simply call the \method{Compile} method on the expression and then 
	emit bytecodes that operate on its result, without caring whether the 
	expression is a huge expression tree or a single constant value. An example 
	of this is the \textsf{ArithmeticExpression} node. In its \textsf{Compile} 
	method it first calls the \method{Compile} method of its left child, then 
	its right child and then emits an \textsf{Add},\textsf{Sub},\textsf{Mul} or 
	\textsf{Div} bytecode. The child nodes of \textsf{Expression} nodes are 
	invariably \textsf{Expression} nodes themselves.

 	\textbf{ActionRestrictions} represents a function that restricts actions 
 	within a process from synchronizing with other actions outside the process. 
 	This is an implementation of the \textit{restriction} process language 
 	construct described in Section~\ref{common_constructs}. It currently has two 
 	concrete descendants. One is \textsf{ChannelRestrictions} which restricts 
 	channels by name, provided that the names of channels to restrict are known 
 	at compile time. The other is \textsf{CustomRestrictions}, that calls a .NET 
 	method at runtime for every action and returns \textbf{true} it it should be 
 	restricted. The method can be written in any language available for the .NET 
 	framework, the only requirements are that it takes an \textsf{Action} object 
 	from the PLR runtime library as a parameter and returns a boolean value.
	 
 	\textbf{PreProcessActions} represents a function that is called for every 
 	action that is performed in a process and returns another action. This is 
 	used to implement the \textit{re-labelling} process language construct 
 	described in Section~\ref{common_constructs}. Simple re-labelling of 
 	channels with names known at compile time is done with a 
 	\textsf{RelabelActions} class. It has the names to re-label as child nodes 
 	and compiles down to a method that takes in an \textsf{Action} runtime class 
 	and performs simple string substitution on its name. More complicated 
 	pre-processing of actions can be achieved with another descendant class, 
 	\textsf{CustomPreprocess}. That class compiles down to a method call to a 
 	.NET method that takes an \textsf{Action} as a parameter and returns an 
 	\textsf{Action} as well. This method can be written in any language 
 	available for .NET.
 	
 	Besides all the descendant classes of those five main classes, there are a 
 	few classes that inherit directly from the \textsf{Node} class. 
 	\textsf{ProcessSystem} is the root node of the entire syntax tree and has a 
 	more complicated \textsf{Compile} method than most other nodes, since it 
 	takes care of setting up the necessary context for the compilation and 
 	creating the actual compiled file, giving it a name and so forth. 
 	\textsf{ProcessDefinition} is a simple class that just has a 
 	\textsf{Process} child node and a name for the process. Finally, 
 	\textsf{ExpressionList} is a convenience class to hold a list of 
 	\textsf{Expression} instances.
 	
\subsection{Integration with other languages}

\subsection{Extensibility}

\subsection{Code generation}
	
	To generate a valid .NET assembly the PLR uses a set of classes that are a 
	part of the .NET framework Base Class Library. These classes are located in 
	the \textit{System.Reflection.Emit} namespace. Before explaining more about 
	these classes it is worth going over how a .NET assembly is structured. A 
	.NET \textit{assembly} is an executable file (.exe) or a dynamic link 
	library (.dll). The assembly contains one more \textit{modules}, typically 
	just one. Each module contains one or more \textit{types} (or classes). 
	Types have \textit{fields}, \textit{constructors} and \textit{methods}. At 
	the lowest level, constructors and methods contain CIL bytecodes. 
	Figure~\ref{fig:assembly} shows the structure.
	
	\TODO{Figure with assembly structure}
	
	The classes in System.Reflection.Emit namespace match the structure of an 
	assembly. There is an \textsf{AssemblyBuilder}, \textsf{ModuleBuilder}, 
	\textsf{TypeBuilder}, \textsf{FieldBuilder}, \textsf{ConstructorBuilder} and 
	a \textsf{MethodBuilder}. These are instantiated by giving them names and 
	other properties as parameters. The \textsf{ConstructorBuilder} and 
	\textsf{MethodBuilder} have a \textsf{GetILGenerator} method that returns an 
	object of type \textsf{ILGenerator}. That object has direct access to the 
	bytecode stream of the method being created, and contains various overloads 
	of an \textsf{Emit} method that emits bytecodes and their associated 
	arguments. An \textsf{OpCodes} class contains constants for all possible 
	bytecodes that can be emitted by the \textsf{ILGenerator}.
	
	The nodes of the syntax tree gain access to these classes through a 
	\textsf{CompileContext} class which is part of the PLR, and is a parameter 
	to the \textsf{Compile} method implemented by all nodes. The 
	\textsf{CompileContext} class has a number of useful properties that the 
	nodes can access. It exposes the \textsf{TypeBuilder} object of the type 
	currently being built, the \textsf{ILGenerator} object of the method or 
	constructor being built and a symbol table for variables currently in scope. 
	The node can then emit its bytecodes, create new variables or otherwise 
	alter the \textsf{CompileContext} before passing it on to its child nodes 
	\textsf{Compile} methods. Essentially this is a form of distributed 
	compiling, no one node has a complete picture of what is being compiled, 
	each node only has enough information to add its own code to the correct 
	type or method.

\subsection{Debugging support}
	
	
	
\section{Runtime Library}
