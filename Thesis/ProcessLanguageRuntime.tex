\chapter{Process Language Runtime}

	This chapter presents the design and implementation of the Process Language 
	Runtime, an extensible compiler backend and a runtime library for running 	
	process languages on the .NET platform. 

\section{Inspiration}

	The inspiration for the Process Language Runtime comes from the Dynamic 
	Language Runtime \TODO{NEED REF} (DLR), a framework from Microsoft for 	
	developing dynamic languages on top of the Common Language Runtime. Since 
	the .NET Common Intermediate Language is statically typed it is ill-suited
	for dynamic languages such as Python, Ruby or JavaScript. To clarify, 
	statically typed languages are languages where the type of a variable is 
	known at compile time and the type of a variable never changes, while in a 
	dynamically typed language a single variable can contain objects of 	
	different types at different times during program execution. The idea of 
	having a common abstract syntax tree for different languages comes from the 
	DLR. However, the DLR was not directly used for this project since its 
	abstract syntax tree is mainly concerned with traditional constructs for 
	imperative programming languages and constructs to support dynamic typing, 
	while the purpose of this project is to provide constructs common to process 
	languages, and dynamic typing is not an issue we are concerned with.

\section{Overview}

	The PLR is a single .NET assembly, named PLR.dll. This assembly contains the 
	abstract syntax tree and associated helper objects as well as all the 
	classes used at runtime. The PLR does not contain any lexer or parser and 
	generally has no notion of any concrete syntax. Creating a lexer and parser 
	is the responsibility of individual language implementations, the PLR takes 
	over once an input file has been parsed and used to construct a PLR abstract 
	syntax tree. 
	
	It is important to note that the PLR does not, nor is it meant 
	to, support all constructs of all process languages. Creating a superset of 
	all existing process languages has never been the goal, instead the goal is 
	to provide a common subset of the most common constructs found in these 
	languages and to make it easy to extend with specific new constructs needed 
	for specific languages. To enable this, the classes and interfaces in the 
	PLR have been engineered to make them easy to subclass and implement.
	
	As the PLR contains classes needed at runtime it must be distributed with 
	any compiled process language application. However, an option is present in 
	the compilation stage that allows the PLR assembly to be embedded in the 
	final compiled executable program, and can optionally embed any additional 
	runtime libraries that specific languages require. This allows a process 
	language program to be distributed as a single file without any external 
	dependencies other than the .NET framework itself.

	The PLR itself is written in the C\# programming language using Visual 
	Studio 2008 as the development environment. It has a dependency on the NUnit 
	unit test framework, however this dependency is only needed when running 
	internal unit tests and so does not need to be distributed with the PLR 
	assembly. The source code for the PLR is licensed under the General Public 
	License (GPL) v3.0.
	
\section{Abstract Syntax Tree}

	The PLR abstract syntax tree is the component that generates CIL 
	bytecode to run a process language application. Once an abstract syntax tree 
	has been constructed, a call to a \method{Compile} method on the tree's root 
	node with the appropriate parameters will create an executable .NET 
	assembly. 

\subsection{Architecture}

	The architecture of the abstract syntax tree is based on Object Oriented 
	principles, namely that an object contains data and methods to operate on 
	that data. As such, each node in the abstract syntax tree knows how to 
	compile itself, there is no compiler class, the whole syntax tree is the 
	compiler. Every node in the syntax tree inherits from an abstract 
	\textsf{Node} base class which has an abstract \textsf{Compile} 
	method. Concrete node classes override the \method{Compile} method and in it 
	emit the appropriate byte codes for the language construct that the node 
	represents. 
	
	The compilation itself is recursive, calling the \method{Compile} method 
	on the root node of the tree will cause it to call the \method{Compile} 
	method of its child nodes, who in turn call \method{Compile} on their child 
	nodes and thus the compilation propagates throughout the entire tree. The 
	reason for choosing this architecture was to make the syntax tree easily 
	extendable by language implementors, who can add new nodes to represent new 
	constructs. 
	
	Concrete nodes typically do not inherit directly from the \textsf{Node} base 
	class, instead they inherit from one of five intermediate classes, 
	\textsf{Action}, \textsf{Process}, \textsf{Expression}, 
	\textsf{ActionRestrictions} or \textsf{PreProcessActions}. Below is a short 
	overview of what each of these classes represents.
	
	\textbf{Action} represents an action taken by the 
	process. This can for instance be sending on a channel, receiving on a 
	channel or calling an arbitrary method. Concrete descendants of this class 
	typically have either no child nodes of their own, or a list of 
	\textsf{Expression} nodes, representing parameters to a method call or 
	values passed through a channel.

	\textbf{Process} is the base class for processes. Its descendants include an 
	\textsf{ActionPrefix} class, a \textsf{NonDeterministicChoice} class and a 
	\textsf{ParallelComposition} class. Implementing a new language construct 
	such as replication could be done be creating a new descendant of this 
	class. Child nodes of \textsf{Process} classes vary, the 
	\textsf{ActionPrefix} class for example has one \textsf{Action} child node 
	representing the action about to be performed and one \textsf{Process} child 
	node representing the process that the current process turns into after 
	performing the action. Processes that are a composition of other processes 
	such as \textsf{ParallelComposition} and \textsf{NonDeterministicChoice} 
	have a list of other \textsf{Process} instances as childnodes.
	
	\textbf{Expression} represents an expression such as an arithmetic 
	expression, numeric or string constant, a method call or the value of a 
	variable.	Expressions compile in such a way that once they have been 
	evaluated a single value, the result of the expression, is at the top of the 
	evaluation stack. This means that a node that has an expression as a child 
	node can simply call the \method{Compile} method on the expression and then 
	emit bytecodes that operate on its result, without caring whether the 
	expression is a huge expression tree or a single constant value. An example 
	of this is the \textsf{ArithmeticExpression} node. In its \textsf{Compile} 
	method it first calls the \method{Compile} method of its left child, then 
	its right child and then emits an \textsf{Add},\textsf{Sub},\textsf{Mul} or 
	\textsf{Div} bytecode. The child nodes of \textsf{Expression} nodes are 
	invariably \textsf{Expression} nodes themselves.

 	\textbf{ActionRestrictions} represents a function that restricts actions 
 	within a process from synchronizing with other actions outside the process. 
 	This is an implementation of the \textit{restriction} process language 
 	construct described in Section~\ref{common_constructs}. It currently has two 
 	concrete descendants. One is \textsf{ChannelRestrictions} which restricts 
 	channels by name, provided that the names of channels to restrict are known 
 	at compile time. The other is \textsf{CustomRestrictions}, that calls a .NET 
 	method at runtime for every action and returns \textbf{true} it it should be 
 	restricted. The method can be written in any language available for the .NET 
 	framework, the only requirements are that it takes an \textsf{Action} object 
 	from the PLR runtime library as a parameter and returns a boolean value.
	 
 	\textbf{PreProcessActions} represents a function that is called for every 
 	action that is performed in a process and returns another action. This is 
 	used to implement the \textit{re-labelling} process language construct 
 	described in Section~\ref{common_constructs}. Simple re-labelling of 
 	channels with names known at compile time is done with a 
 	\textsf{RelabelActions} class. It has the names to re-label as child nodes 
 	and compiles down to a method that takes in an \textsf{Action} runtime class 
 	and performs simple string substitution on its name. More complicated 
 	pre-processing of actions can be achieved with another descendant class, 
 	\textsf{CustomPreprocess}. That class compiles down to a method call to a 
 	.NET method that takes an \textsf{Action} as a parameter and returns an 
 	\textsf{Action} as well. This method can be written in any language 
 	available for .NET.
 	
 	Besides all the descendant classes of those five main classes, there are a 
 	few classes that inherit directly from the \textsf{Node} class. 
 	\textsf{ProcessSystem} is the root node of the entire syntax tree and has a 
 	more complicated \textsf{Compile} method than most other nodes, since it 
 	takes care of setting up the necessary context for the compilation and 
 	creating the actual compiled file, giving it a name and so forth. 
 	\textsf{ProcessDefinition} is a simple class that just has a 
 	\textsf{Process} child node and a name for the process. Finally, 
 	\textsf{ExpressionList} is a convenience class to hold a list of 
 	\textsf{Expression} instances.
 	
\subsection{Extensibility}
	
	As stated before, one of the goals of the PLR is extensibility, allowing
	for language implementors to add features and constructs not included in
	the PLR itself. There are three main methods of extending the PLR. Firstly,
	language implementors can add new nodes to the abstract syntax tree. These
	nodes just have to implement the \textsf{Compile} method and then they can
	be seamlessly integrated with the built in PLR nodes. Of course it is also
	possible to inherit from one of the existing nodes and thereby re-using some
	of the compilation work they do, and simply adding extra code before or after
	the base classes compilation step. 
	
	Secondly, the root node of the abstract	syntax tree, \textsf{ProcessSystem} 
	exposes the following four events. 
	
	\begin{enumerate}
		\item \textsf{BeforeCompile} occurs before the PLR has performed any 
		compilation. At this point only the \textsf{AssemblyBuilder} and 
		\textsf{ModuleBuilder} have been defined, no types or methods exist yet.
		
		\item \textsf{AfterCompile} occurs after the PLR has finished all its
		compilation but before it creates the executable file. At this point
		subscribers to this event can access any types or methods created during
		compilation.
		
		\item \textsf{MainMethodStart} occurs just after the main method of the
		application has been defined but before any bytecodes have been emitted
		into it. Subscribers of this event can then inject their own bytecodes at the
		beginning of the main method if they wish.
		
		\item \textsf{MainMethodEnd} occurs after all bytecodes of the main method
		have been emitted, except for the final \textsf{Ret} instruction. Again, 
		subscribers of this event can inject their own bytecodes at this point.
	\end{enumerate}
	
	All these events have the same signature, they require a \textsf{CompileEventHandler}
	delegate, which takes a \textsf{CompileContext} as a parameter. The event
	subscribers then use the compile context to create types, methods and emit
	bytecodes at different points in the compilation process.
	
	Finally, the third way to extend the PLR is to write supporting code in
	another .NET language, writing a seperate runtime library. The KLAIM implementation
	described in Chapter~\ref{ch:klaim} takes this approach. When a language
	implementation requires large amounts of supporting code it is inconvenient
	and error prone to generate all that code by emitting CIL bytecode at 
	compilation time. By creating a runtime library instead, language implementors 
	can get the benefit of programming languages and tools such as C\# and Visual 
	Studio when writing the common, re-usable parts of their languages. Then, at
	compilation time, they can simply emit bytecodes to call code in the runtime
	library. This is also the approach taken by the PLR itself, which has runtime
	classes written in C\# and emits bytecodes during compilation that interact
	with these classes.	

\subsection{Code generation}
	
	To generate a valid .NET assembly the PLR uses a set of classes that are a 
	part of the .NET framework Base Class Library. These classes are located in 
	the \textit{System.Reflection.Emit} namespace. Before explaining more about 
	these classes it is worth going over how a .NET assembly is structured. A 
	.NET \textit{assembly} is an executable file (.exe) or a dynamic link 
	library (.dll). The assembly contains one more \textit{modules}, typically 
	just one. Each module contains one or more \textit{types} (or classes). 
	Types have \textit{fields}, \textit{constructors} and \textit{methods}. At 
	the lowest level, constructors and methods contain CIL bytecodes. 
	Figure~\ref{fig:assembly} shows the structure.
	
	\TODO{Figure with assembly structure}
	
	The classes in System.Reflection.Emit namespace match the structure of an 
	assembly. There is an \textsf{AssemblyBuilder}, \textsf{ModuleBuilder}, 
	\textsf{TypeBuilder}, \textsf{FieldBuilder}, \textsf{ConstructorBuilder} and 
	a \textsf{MethodBuilder}. These are instantiated by giving them names and 
	other properties as parameters. The \textsf{ConstructorBuilder} and 
	\textsf{MethodBuilder} have a \textsf{GetILGenerator} method that returns an 
	object of type \textsf{ILGenerator}. That object has direct access to the 
	bytecode stream of the method being created, and contains various overloads 
	of an \textsf{Emit} method that emits bytecodes and their associated 
	arguments. An \textsf{OpCodes} class contains constants for all possible 
	bytecodes that can be emitted by the \textsf{ILGenerator}.
	
	The nodes of the syntax tree gain access to these classes through a 
	\textsf{CompileContext} class which is part of the PLR, and is a parameter 
	to the \textsf{Compile} method implemented by all nodes. The 
	\textsf{CompileContext} class has a number of useful properties that the 
	nodes can access. It exposes the \textsf{TypeBuilder} object of the type 
	currently being built, the \textsf{ILGenerator} object of the method or 
	constructor being built and a symbol table for variables currently in scope. 
	The node can then emit its bytecodes, create new variables or otherwise 
	alter the \textsf{CompileContext} before passing it on to its child nodes 
	\textsf{Compile} methods. Essentially this is a form of distributed 
	compiling, no one node has a complete picture of what is being compiled, 
	each node only has enough information to add its own code to the correct 
	type or method.

\subsection{Debugging support}
	
	One of the benefits of targeting a common virtual machine such as the CLR is
	is that both a free command line and graphical debugger exist that can be used
	for any programming language that compiles down to the Common Intermediate
	Language format. The \textit{System.Reflection.Emit} API offers functionality 
	to emit the necessary debugging symbols to be able to use these debuggers.
 	Emitting debug symbols consists of the following five steps:
 	
 	\begin{enumerate}
 		\item When the \textsf{ModuleBuilder} objects is defined with a call to the 
 		\textsf{DefineDynamicModule} method on the \textsf{AssemblyBuilder} object, a
 		parameter named \textsf{emitSymbols} should be passed as \textbf{true}.
 		
		\item An item of the type \textsf{ISymbolDocumentWriter} needs to be defined. 
		This is done with a call to a \textsf{DefineDocument} method on the 
		\textsf{ModuleBuilder} object which returns a \textsf{ISymbolDocumentWriter} 
		object. The parameters to this method call include the name of the source 
		file that is being compiled, this is neccessary so that the debugger can 
		prompt for the source file when debugging the compiled file. The 
		\textsf{ISymbolDocumentWriter} object is passed with the \textsf{CompileContext}
		to all nodes during compilation.

		\item Local variables in methods are created with a \textsf{LocalBuilder} 
		object. In a non debug build these locals are not stored by name in the 
		compiled file, but simply given a number and referred to by that number.
		To be able to map variables in the compiled file to variable names in the
		source file a method, \textsf{SetLocalSymInfo} is called on the 
		\textsf{LocalBuilder} object. The method takes the name of the variable as
		a parameter and stores that information for later use by the debugger.
		
		\item The method \textsf{SetUserEntryPoint} must be called on the 
		\textsf{ModuleBuilder} object to enable the debugger to know what the entry
		method of the assembly is. The method takes a \textsf{MethodBuilder} object
		as a parameter.
		
		\item The most important part of emitting the debug symbols is marking 
		\textit{sequence points} in the CIL bytestream. A sequence point is a point 
		in the bytecode that tells the debugger to stop at that point during code
		execution and highlight a particular section in the source code file. To be
		able to do this the sequence point contains information about a start position
		and end position in the source file, given as line and column numbers. A 
		sequence point is marked with a call to a \textsf{MarkSequencePoint} method
		on an \textsf{ILGenerator} object, the methods parameters are an instance
		of \textsf{ISymbolDocumentWriter} and four integers, startLine, startColumn,
		endLine and endColumn. Figure~\ref{fig:sequence_points} shows a few lines
		of CIL bytecode interspersed with sequence points. (Note: the CIL file
		format does not store sequence points in exactly this manner, the figure
		is simply meant to clarify the concept). It is worth noting that the CIL has 
		no notion of statements, expressions or other programming language constructs,
		it is perfectly legal to insert a sequence point in the middle of an expression
		or anywhere else in the bytecode. It is completely up to the programmer to
		insert sequence points at meaningful points in the bytestream according to
		the semantics of the language being implemented.
		
 	\end{enumerate}
 	
 	The PLR handles these five steps, so an implementation of a language that uses
 	the PLR as its backend compiler does not need to concern itself with them directly. 
 	However, since the PLR does not handle parsing of source files it can not 
 	determine itself the line and column numbers needed for marking sequence points.
 	For that purpose, every node in the PLR abstract syntax tree has an instance of
 	a class named \textsf{LexicalInfo}. This class is simply a wrapper around the
 	four integers that a sequence point needs, startLine, startColumn, endLine and
 	endColumn. This information is easily available during parsing and so the 
 	individual language parsers should store this information for each node. The PLR
 	will then automatically emit a sequence point before every \textit{action} 
 	taken by a process.


	
\section{Runtime Library}

	The PLR has a small runtime library consisting of nine classes. These classes
	reside in the \textsf{PLR.Runtime} namespace. Applications
	compiled using the PLR must have access to this library at runtime in order
	to execute successfully. Figure~\ref{fig:runtime_library} shows a class 
	diagram of the runtime library. Below is an overview of each of the
	nine classes.

	\textbf{ProcessBase} is an abstract base class for any compiled processes.
	It contains methods used to interact with the \textsf{Scheduler},
	for instance method to synchronize on channels, methods for startup and
	termination as well as methods to suspend and resume the process thread.
	Since processes are built up into a tree-like structure at runtime (further 
	explained in Section~\ref{cil_structure}) it also contains a field for its 
	parent \textsf{ProcessBase} instance, as well as a list of 
	\textsf{ProcessBase} instances which are its child nodes in the tree. Finally, 
	it contains a list of \textsf{IAction} instances, this list will hold all 
	actions that occur in the process instance or any of its subprocesses and are 
	restricted by the instances restriction clause.
	
	\textbf{BuiltIns} is a small static class that contains utility methods
	that can be called by processes, such as to print to the console.
	
	\textbf{IAction} is an interface that all runtime actions must implement.
	It contains four methods. \textsf{ProcessID} returns the id of the
	process performing the action, \textsf{IsAsynchronous} returns true if
	the action can be executed without synchronizing with another action, 
	this applies for instance to arbitrary method calls to .NET methods.
	\textsf{CanSyncWith(IAction other)} determines whether the action can be 
	synced with another action, in the case of asynchronous actions this
	method always returns false. Finally, \textsf{Sync(IAction other)} is 
	called on those actions that have been chosen for execution and is used
	for example to pass values from one process to another through channels.

	\textbf{ChannelSyncAction} is a class representing synchronization on a
	channel. It contains the channel name, the id of the process performing
	the action and information about whether the process is attempting to send
	or receive on the channel. In the case of a send operation it can optionally
	contain a list of values that are being sent, and in the case of a receive
	operation it can contain a list of variables that should be bound to the 
	values being sent from the other side. The \textsf{ChannelSyncAction}
	implements the \textsf{IAction} interface as all runtime actions must, it is
	a synchronous action and its \textsf{CanSyncWith} method will only return 
	true for other \textsf{ChannelSyncAction} instance that have the same
	channel name, are performing the opposing operation and have the same
	number of values being passed through the channel. When two actions are
	synchronized, the \textsf{Sync(IAction other)} method on both the actions
	are called with the other actions as a parameter. In the case of channel 
	synchronizations the action instance which represents the receiving end
	of the operation will bind its variables to the values passed through
	the channel in its \textsf{Sync} method, the sending action will do nothing
	in its own \textsf{Sync} method.
	
	\textbf{MethodCallAction} is a runtime action which can be used to call
	an arbitrary .NET method, either a built-in method from the .NET base
	class library or a method from any .NET assembly. It is an asynchronous 
	action and as such does not need to synchronize with another process to be 
	executed. Currently	the PLR provides support for calling static methods 
	that have integers or	strings as parameters. This allows for instance most
	of the methods from the \textsf{System.Math} class to be accessible. To
	gain access to instance methods, for example the \textsf{NextInt} method
	of the \textsf{System.Random} class, it is necessary to write static wrappers
	around the methods.

	\textbf{Logger} is a utility class for handling process output to the screen.
	Its main feature is assigning a different color to each process to 
	easily distinguish between them in the console output.

	\textbf{GlobalScope} is a small class whose only purpose is to be a 
	repository of possible actions that are not restricted by any process. As
	explained in Section~\ref{cil_structure}, candidate actions are propagated up 
	the process tree, and at each process it is checked whether the process 
	restricts them, if so they are stored within that process so that they do
	not synchronize with actions outside the process. In the case where no
	process restricts the action and it can synchronize with any other action
	that is not otherwise restricted then the action is stored in the global scope,
	while it waits to see whether it was chosen for execution.
	
	\textbf{ProcessKilledException} is an exception class used when processes
	are killed. As an example, when a process is a candidate in non deterministic
	choice and is not chosen then it must be killed. To bypass all the subsequent
	actions of the process, a \textsf{ProcessKilledException} is thrown and then
	caught at the end of the processes code. There the process will unregister
	itself from the \textsf{Scheduler}, print a message to the console and then
	terminate.
	
	\textbf{Scheduler} is the real execution engine of the PLR. It follows the
	\textit{Singleton} \TODO{NEEDREF} design pattern so it is trivial for all
	processes in the application to gain access to the same \textsf{Scheduler}
	instance. When processes are activated they register themselves with the 
	scheduler, which keeps a list of active processes. The scheduler then monitors
	the processes and waits until all processes have generated all their candidate
	actions and are waiting for an action to be executed so they can continue.
	At that point the scheduler goes through all the possible actions, figures
	out which actions can sync with each other and then randomly chooses an
	action to execute. It then executes the action and wakes up the processes
	involved in the action so that they can resume execution. It also terminates
	certain processes (or rather instructs them to terminate themselves). These
	are generally candidates of non deterministic choice who were not chosen. 
	Once the scheduler has finished one such round it again waits until all 
	the processes it woke up are again suspended and then chooses the next
	action to execute, and so on. Example~\ref{ex:scheduler} shows the workings
	of the scheduler in pseudocode. Other responsibilities of the scheduler are
	everything to do with thread locking and synchronization, and keeping track of
	the \textit{trace}, that is the list of actions executed during the duration
	of the program.
	 

\section{CIL Structure of a Process Language Application}\label{cil_structure}

	A process language application is in many ways different from an application
	written in a traditional programming language. One of the goals of this 
	project was to investigate how well process languages are suited to the .NET
	virtual machine. We now look at how a process language system looks 
	once it has been compiled to the Common Intermediate Language.
	
	One of the hardest decisions during the design of the PLR was whether or not to
	represent each process as a separate thread. Writing multi-threaded code is 
	hard,	and it is subject to subtle errors, race conditions and other problems
	that are easily avoided when using only a single thread. However, a single
	threaded implementation would be forced to represent the processes as data 
	structures, rather than as independent programs in their own right. That 
	approach, that the processes are datastructures and the program is a single
	thread operating on those datastructures is certainly worthwhile, and in fact 
	an early prototype was implemented as an interpreter that did just that. It
	even makes certain things easier, such as the visualizing the state of the 
	processes after each round. However, using multiple threads allowed for 
	compiling each process relatively independently of other processes, and 
	conceptually seemed closer to the semantics of process algebra. Another
	benefit of the multi-threaded approach was that it made emitting debug symbols
	fairly simple, while doing the same in a single threaded way would have
	been problematic. For these reasons the multi-threaded approach was taken.
	
	Each process in process algebra maps to a class in CIL. The top level 
	processes, those that are defined as named process constants, are compiled
	to classes named after the process constant. A top level class can have
	multiple inner classes however, and each of those can itself have multiple
	inner classes. This happens for instance when a process starts by performing
	an action and then turns into a process that is a parallel composition of 
	other processes. In that case each of those parallel processes is an inner
	class of the original top level process. The same thing happens when a 
	named process makes a non-deterministic choice; each of the choices is its
	own inner class. The reason for making these inner classes was that in a
	fairly large system the number of classes quickly becomes large,
	and instead of polluting the top level namespace with dozens of generated 
	class	names, they are confined within their owning process. It is also
	easier to understand what each process represents, the class name
	\textsf{Teacher+Parallel1} represents the first parallel process within
	the \textsf{Teacher} process, which is a parallel composition process.
	
	Restrictions and re-labellings map to methods in CIL. The methods do not
	have to be member methods of a process class, there is an extra layer
	of indirection to allow for calling methods in external assemblies. The
	\textsf{ProcessBase} class has two methods, \textsf{GetPreProcess} and 
	\textsf{GetRestrict}. These methods return delegates (otherwise known as
	function pointers) to a preprocess function (such as a relabelling function)
	and a restriction function, respectively. The base class version of
	\textsf{GetPreProcess} and \textsf{GetRestrict} return function pointers to
	methods that do not alter or restrict any actions. Concrete process classes
	can override these methods and return function pointers to other methods,
	either methods in the process class itself, or methods in some external
	assembly.
