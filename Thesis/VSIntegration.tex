\chapter{Integrated Development Environment}\label{ch:ide}

	One of the biggest differences between academic programming languages and 
	industrial programming languages is the level of tool support. Academic 
	languages traditionally are edited in text editors and compiled with command 
	line tools, while industrial languages usually have integrated development 
	environments (IDE's). These environments offer a wide range of features such 
	as syntax highlighting, instant visual warnings about syntax errors, 
	background compilation, automatic listing of available methods and variables 
	(IntelliSense), built in debuggers and refactoring. One of the goals of this 
	project was to explore how well the CCS language could be integrated into 
	one of these environments and how it could benefit from the features they 
	have to offer. This chapter presents the results of this exploration. 
	
\section{Choice of Integrated Development Environment}
	
	When choosing which IDE would be most suitable for CCS two environments 
	stood out. First there is Microsoft's Visual Studio which is the most 
	popular environment for .NET development. Visual Studio versions are 
	released alongside new version of the .NET framework itself and each new 
	version takes full advantage of and supports all the new features in the 
	.NET framework. The latest version as of this writing is Visual Studio 2008 
	which supports the .NET framework 3.5. Visual Studio has an extensibility 
	API based on COM technology, an older technology for interaction between 
	programs written in different programming languages. Languages are 
	integrated by creating \textit{language services}, the Visual Studio program 
	itself is simply a host for these services. The languages that come with 
	Visual Studio, C\# and Visual Basic.NET have their own language services 
	that do not have any special access to Visual Studio, this implies that a 
	language service for a new language can be made to offer all the same 
	features as those supported by the built in languages.
	
	The second candidate for a CCS development environment was SharpDevelop, an 
	open source IDE written entirely in C\#. SharpDevelop is very similar to 
	Visual Studio and offers many of the same features. Its extensibility API is 
	entirely in .NET and is in many ways cleaner and clearer than Visual 
	Studio's API. It also has the benefit of being open source software, so it 
	is easy to get a clearer picture of its architecture, and view the source 
	for other language services. The architecture of SharpDevelop itself has 
	even been the subject of a book, \cite{sharpdevelop}. The drawbacks
	are that its debugger is inferior to Visual Studio's, the application itself
	is slower, and it is not as well known as Visual Studio.
	
	After researching both environments, Visual Studio 2008 was chosen as the one
	to implement CCS's language service in. This was based primarily on the fact
	that Visual Studio is the IDE of choice for most .NET developers, it is fast 
	and offers great debugging support. While the standard versions of Visual 
	Studio are not free, it is possible to download only the Visual Studio shell 
	and distribute it for free, the shell is the Visual Studio program itself 
	without any language services. This makes it possible to offer the CCS 
	development environment free of charge to anyone who wishes to use it.
	
\section{Building a language service}
	
	The goal of this integration was to be able to use Visual Studio to manage 
	all aspects of working with the CCS language. To achieve that the following 
	features needed to be implemented:
	
	\begin{enumerate}
		\item \textbf{CCS Projects}. The ability to create new projects 
		specifically for CCS applications.

		\item \textbf{Syntax highlighting}. To have different tokens of the 
		language colored differently so that it is easier to see and understand 
		the structure of the code.
		
		\item \textbf{Real time syntax checking}. Visual warnings about 
		incorrect syntax in the code as it is being written. 
	
		\item \textbf{Match parentheses}. When working with large expressions it 
		can be hard to see which parentheses match, and missing parentheses are a 
		common syntax error. Visual Studio can highlight the matching parentheses 
		automatically, if the language service provides it with the necessary 
		information about which parentheses match each other.
		
		\item \textbf{Build support}. To be able to compile the code being written 
		from within Visual Studio, using its \textit{Build} menu items and 
		commands. A part of that is being able to use Visual Studio's built in 
		mechanism to search for and add references to other .NET assemblies that 
		the application uses, and pass those references to the compiler at compile 
		time.
		
		\item \textbf{Debugger support}. Launching the application after it had 
		been built and attaching the Visual Studio debugger to the running 
		executable. Also the ability to set breakpoints and step through the code 
		as it is executing.
		
	\end{enumerate}
	
	The implementation of these features is described in the following 
	sections.

	
	\subsection{Visual Studio API}	
	The COM extensibility API for Visual Studio is fairly complicated and 
	unfriendly to use. It is also poorly documented. Fortunately Microsoft has 
	recently released a framework called the Managed Package Framework, or MPF 
	for short. This comes as part of the Visual Studio SDK (Software Development 
	Kit) and is a collection of .NET classes that wrap a lot of the underlying 
	COM interface, making it easier to work with in .NET languages. 
	The MPF classes implement much of the tedious boilerplate code which is 
	necessary and common to all language services. Parts of the Managed Package 
	Framework are released only as source code and are meant to be included 
	directly in language service projects when they are being built. In the 
	source code repository for this project, these files have been marked 
	specifically with a header stating that they are supplied by Microsoft to 
	avoid confusion about which code is original work and which code is 
	borrowed. 

	\subsection{Syntax Highlighting}
	Syntax highlighting is when different tokens in a language are given 
	different color to help differentiate them when looking at code. This
	is very helpful when looking at code to quickly sense the structure and
	identify problems, and has been a standard feature of development 
	environments as well as most advanced text editors for many years. In many
	common text editors this is simply implemented as lists of tokens and 
	colors for them. The Managed Package Framework however requires that the 
	language service provides an implementation of an interface named 
	\textsf{IScanner}, with two methods named \textsf{SetSource} and
	\textsf{ScanTokenAndProvideInfoAboutIt}. The \textsf{SetSource} method is 
	called by Visual Studio and provides the \textsf{IScanner} with one line of 
	source code at a time, it then repeatedly calls 
	\textsf{ScanTokenAndProvideInfoAboutIt} to get information about each of the 
	tokens in that line. For this project the \textsf{IScanner} interface was 
	implemented using a lexer class, how that class was generated is described 
	further in Section~\ref{sec:syntax_checking}. The tokens of the language 
	were divided up into eight distinct color classes and colored as follows:
	
	\begin{itemize}
		\item Process constants - Greenblue
		\item Output actions on channels	- Dark gray
		\item Method calls - Magenta
		\item Comments - Dark green
		\item Strings - Maroon
		\item Keywords - Blue
		\item Numbers - Red
		\item All other tokens - Black
	\end{itemize}

	An example of the syntax highlighting can be seen in 
	Figure~\ref{fig:syntaxcheck}.
	
	\subsection{Real time syntax checking}\label{sec:syntax_checking}
	A very useful feature of Visual Studio is its ability to show the user 
	errors in their code in real time, as they are typing. These errors (or 
	warnings) are shown both as text error messages in an error message window, 
	as well as red curvy lines under the places in code where the syntax errors 
	occurs. This makes it extremely easy to look at a page of code and determine 
	whether it is syntactically correct. Figure~\ref{fig:syntaxcheck} shows an 
	example of this feature in action.
	
	\begin{figure}[h!]
		\centering
		\includegraphics[scale=0.7]{syntaxcheck.jpg}
		\caption{Syntax checking for CCS in Visual Studio}
		\label{fig:syntaxcheck}
	\end{figure}

	The component in Visual Studio that is responsible for syntax highlighting 
	and syntax checking is named Babel. As part of the Managed Package Framework 
	there is a collection of classes to wrap this component, these are called 
	the Managed Babel System. With the Managed Babel System come two programs 
	called MPLex.exe and MPPG.exe, these acronyms stand for \textit{Managed 
	Package Lex} and \textit{Managed Package Parser Generator}. These are .NET 
	implementations of the well known parser generator tools Lex and YACC and 
	derive directly from the \textit{Garden Point Parser Generator} \cite{gppg} 
	developed at the Queensland University of Technology. These tools take as 
	input a \textsf{lexer.lex} file and
	\textsf{parser.y} file. The lexer file defines the tokens of the language
	with regular expressions, and the parser file describes the syntax of the
	language in extended Backus-Naur form, or EBNF. From these input files 
	MPLex.exe and MPPG.exe generate C\# code for a lexer and a parser for the 
	language. A more detailed explanation of Lex and YACC-like tools is outside 
	the scope of this paper but a useful book on the subject is \cite{lexyacc}. 
	
	Once the generated lexer and parser have been built, Visual Studio is 
	responsible for calling them repeatedly in the background while the user is 
	typing code. Visual Studio then gets a collection of errors and warnings 
	from the parser and displays them to the user. 

	As we saw in Chapter~\ref{ch:ccs_implementation} the parser used by the CCS 
	compiler itself was written using the Coco/R parser generator. It would have 
	been preferable to re-use that parser directly, instead of defining a new 
	parser for the same input language. While it would have been possible, the 
	fact is that MPLex.exe and MPPG.exe are optimized for generating parsers 
	that work well with the Managed Babel System, and the Managed Babel 
	infrastructure expects parsers and lexers that conform to a certain 
	interface. For that reason MPLex and MPPG were used to create a new parser 
	and lexer instead of re-using the existing ones. The drawback to this is of 
	course that two implementations of the same language need to be maintained 
	and kept in sync. However, the input language for both these parser 
	generators is based on EBNF syntax and so it is fairly trivial to port from 
	one to the other. In hindsight the best approach would have been to use MPPG 
	and MPLex for the CCS compiler as well as the language service.
	
	
	\subsection{IntelliSense}
	\TODO{Implement and describe intellisense}

	\subsection{CCS Project and item templates}
	To enable a user to create new CCS projects inside Visual Studio it was 
	necessary to create templates for these files. This was done by creating 
	three files:
	
	\begin{itemize}
		\item \textbf{CCSProject.vstemplate} is a xml file that describes the 
		project type. It contains the name of the project type, unique identifier 
		for it and various parameters such as whether a new project should be 
		created in a new folder. This is the file Visual Studio uses to create an 
		item for CCS in the \textit{New project} dialog.
		
		\item \textbf{project.ccsproj} is a template for new CCS projects. It 
		contains information about debug and release configurations, the name of 
		included CCS sourc files, which assemblies should be referenced by default 
		as well as references to the build tasks to execute to compile CCS 
		projects. Build tasks are further explained in Section~\ref{msbuild}.
		
		\item \textbf{Program.ccs} is a template for CCS source files. It contains
		nothing but a small comment explaining that CCS code should go here. 
	
	\end{itemize}
	
	These three files are put in a zip archive which is stored in a subfolder of
	the Visual Studio main folder. Once this has been done the user can select 
	\textit{CCS Project} as a project type when creating new projects in Visual 
	Studio. For more complex languages an item template could also be created to
	allow users to add additional source files to the program. Since the current
	CCS compiler only supports compiling a single source file this feature was 
	not added, when a user initially creates a new project he gets one source 
	file named \textsf{program.ccs} added automatically, all source code must go
	inside that file.

	\subsection{Build support}\label{msbuild}
	
	...
	
	\section{Summary}
	