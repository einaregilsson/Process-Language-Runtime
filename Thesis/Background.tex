\chapter{Background}

	To fully understand the issues involved in creating the Process Language 
	Runtime, a little background knowledge is required. First, Process 
	languages are explained, their history, common traits and practical 
	applications. Secondly, the .NET framework is presented and its technology
	explained.

\section{Process Languages}

\subsection{Overview and history}

	Process Languages, also known as Process Algebras or Process Calculi, are a
	family of languages to formally model concurrent systems. These languages 
	describe the systems at a high level of abstraction, as interactions, 
	communications, and synchronizations between a collection of independent
	processes. This is typically done using only a handful of constructs, many 
	of which are shared between different process languages, albeit 
	with different concrete syntax. These common constructs are explained 
	further in Section~\ref{common_constructs}. Some of the more prominent 
	process languages today include Calculus of Communicating Systems (CCS), 
	Communicating Sequential Processes (CSP), $\pi$-calculus and Kernel Language 
	for Agents Interaction and Mobility} (KLAIM).
	
	Algebraic laws have been defined for these languages that allow process 
	descriptions or equations to be analyzed and manipulated, and permit formal 
	reasoning about equivalences between different processes, using for instance 
	bi-simulation. In this paper we do not focus on these algebraic properties 
	but instead concern ourselves with their implementations as programming 
	languages. For those interested, a good explanation of the algebra involved 
	can be found in NEEDREF and NEEDREF. 
	
	MORE ABOUT HISTORY...
		
	
\subsection{Common constructs}\label{common_constructs}
	
	\textbf{Parallel composition} is the key construct which separates process 
	algebra from sequential modes of computation. With parallel composition, two 
	or more processes can run independently of each other at the same time. 
	Parallel composition is typically represented with the $|$ character, so for 
	two parallel processes, $P$ and $Q$, we write $P\ |\ Q$ to indicate that 
	they run in parallel.

	\textbf{A null process} is a process that does nothing and cannot interact 
	with any other processes. It has different representations in different 
	algebras, common symbols for it include \textbf{nil}, \textbf{0} and 
	\textbf{STOP}. The purpose of the null process is to be an anchor upon which 
	more interesting processes can be generated. An usual pattern is for a 
	process is to first perform one or more actions and then turn into the null 
	process, which signifies that it has run its course.
	
	\textbf{Message passing through channels} is the way processes interact with 
	each other. One process sends an outbound message on a particular named 
	channel and another process accepts a message on the same named channel. An 
	example of this, with syntax from the Calculus of Communicating Systems is:
	
			1. P = %coffee . 0
			2. Q = %_coffee_ . 0
			
	In this example the process $P$ listens on the \textsf{coffee} channel while 
	process Q sends on it. A process that is sending or receiving on a 
	particular channel is blocked until another process performs the opposite 
	operation on the channel. A synchronization happens between one sender and 
	one receiver, if two processes had been ready to receive on the 
	\textsf{coffee} channel at the same time then one of them would be chosen 
	and the other would remain blocked. Channels are often given descriptive 
	names to indicate their purpose, in the example above we read it as $P$ 
	receives coffee from $Q$. However, values can also be passed along channels, 
	and can then be bound to variables in the receiving process. An example of 
	this is shown below.
	
			1. Teacher = $\overline{grade(12)}$
			2. Student = $grade(x) . 0$
	
	In this example the \textsf{Teacher} process sends the value 12 on the 
	\textsf{grade} channel. The \textsf{Student} process receives the message on 
	the channel and binds the value to a variable $x$ which can then be used in 
	the rest of the process.
	
	\textbf{Action prefixing} is how sequential processes are built up. When a process sends or receives on a channel it is blocked until an opposite process receives or sends on the same channel. For example if process $P$ did not exist, then

	\textbf{Nondeterministic choice}

	\textbf{Process constants}
	
\subsection{Implementations}
	
%In computer science, the process calculi (or process algebras) are a diverse %family of related approaches to formally modelling concurrent systems. %Process calculi provide a tool for the high-level description of %interactions, communications, and synchronizations between a collection of %independent agents or processes. They also provide algebraic laws that allow %process descriptions to be manipulated and analyzed, and permit formal %reasoning about equivalences between processes (e.g., using bisimulation). %Leading examples of process calculi include CSP, CCS, ACP, and LOTOS.[1] More %recent additions to the family include the ?-calculus, the ambient calculus, PEPA and the fusion calculus.

\section{The .NET Framework}

\subsection{Overview and history}
	The .NET Framework is a framework from Microsoft for writing software 
	applications. It consists of a virtual machine that runs programs coded 
	specifically for the framework and a large standard library for application 
	developers to use when writing their applications. In addition, two 
	programming languages are included in the default distribution of the 
	framework, C\# and Visual Basic.NET. (A third language, J\#, was included in
	earlier versions but has since been dropped).

	The original name for .NET was Next Generation Windows Services (NGWS) and its
	development started in the late 1990's at Microsoft. In late 2000 the first 
	beta versions of .NET 1.0 were released, and the first official version of the
	.NET framework, 1.0, was released on February 13th, 2002. As of this writing 
	there have been five major releases of the framework, 1.0, 1.1, 2.0, 3.0 and 
	3.5. With each new version additional features have been added, but not always 
	in the way you would expect. The first three versions, 1.0, 1.1 and 2.0 all 
	contained new versions of the virtual machine, new versions of the compiler 
	for the standard languages and additional libraries. However, version 3.0 of 
	the framework contained only new libraries but no new compilers or new version 
	of the virtual machine. Version 3.5 then included new versions of C\# and 
	Visual Basic.NET and some additional libraries, but again no change to the 
	virtual machine. As a result, the version numbers of the different components 
	of the framework have diverged so when we talk about version 3.5 of the 
	framework, that includes version 3.5 of the libraries, version 2.0 of the 
	virtual machine and version 3.0 of the C\# language. 

\subsection{Common Language Infrastructure}

	The Common Language Infrastructure (CLI) is an open specification developed by
	Microsoft that describes an executable code and runtime environment. This is 
	Microsoft's specification of the .NET framework, but it has been published 
	under ECMA-335 and ISO/IEC 23271 and so anyone is free to write their own 
	version that follows this specification. Two main alternate versions exist, 
	Mono and DotGNU. Both of these are released under open source licenses and 
	work on multiple operating systems, as opposed to Microsoft's .NET which only 
	runs on the Windows family of operating systems. Microsoft has also released a 
	shared source reference implementation of the CLI specification. None of these 
	other implementations fully implement all the class libraries of the original 
	.NET framework, and typically are about one version behind Microsoft's .NET 
	framework.

	The five main components described by the CLI specification are as follows:

	\begin{enumerate}
		
		\item \textbf{The Common Type System (CTS):} a set of types and operations 
		that are shared by all CLI-compliant programming languages.
		
		\item \textbf{Metadata:} Any CLI language can access code written in any 
		other CLI language. To achieve this, information about program structure is 
		language agnostic.
	
		\item \textbf{Common Language Specification (CLS):} A set of base rules to 
		which any language targeting the CLI should conform in order to interoperate 
		with other CLS-compliant languages. The CLS rules define a subset of the 
		Common Type System.
	
		\item \textbf{Virtual Execution System (VES):} The VES is the component that
		loads and executes CLI-compatible programs. 
	
		\item \textbf{Common Intermediate Language (CIL):} An intermediate language 
		that is abstracted away from the platform hardware. Upon execution, the 
		platform-specific VES will use a Just-in-time (JIT) compiler to compile the 
		CIL to hardware specific assembly language. Common Intermediate Language is 
		often referred to under the names MSIL (Microsoft Intermediate Language) or 
		simply as .NET bytecode.

	\end{enumerate}
    
\subsection{Languages}
	
	Two programming languages are included in the .NET default distribution. Those
	are C\# and Visual Basic.NET. C\# derives its syntax from the C family of 
	languages, and in its first version was almost identical to the Java 
	programming language. Later versions have acquired a number of new features 
	such as lambdas, anonymous delegates and generators. In theory all .NET 
	languages are created equal; in practice C\# is first among equals, and the 
	entire standard library is for instance written in C\#. 

	Visual Basic.NET derives from the Basic family of languages. It has more 
	verbose syntax than C\# and is the continuation of Microsoft's Visual Basic 6 
	language. Visual Basic.NET has a number of differences from previous version 
	of Visual Basic though, mainly to fit into the .NET mold. To ease the 
	transition from Visual Basic 6 to Visual Basic.NET, Microsoft included a 
	number of old Visual Basic functions with the .NET framework in the namespace 
	Microsoft.VisualBasic. 
	
	In addition to these two main languages, there are dozens of other 
	languages that have implementations targeting .NET. These include well 
	established languages such as C++, Delphi, Lisp, Scheme, Smalltalk, Java 
	(in J\#), Python, Cobol, Ruby and JavaScript as well as languages that have 
	been built for .NET from the start, such as F\#, Nemerle and Boo.

\subsection{Virtual machine}

	The virtual machine, of the .NET framework is named the Common Language 
	Runtime (CLR). It manages the runtime requirements of programs written for 
	.NET and frees the programmer from having to consider specific machine 
	architectures or CPU's, as far as the programmer is concerned the CLR is the 
	(virtual) machine architecture that they are targeting. The CLR also provides 
	other runtime services such as security, exception handling and memory 
	management. Of these, perhaps the most important service provided is memory 
	management, which frees the programmer from allocating and de-allocating 
	memory at runtime. Some of the most common programming errors in languages 
	without memory management, such as C++, have to do with failing to de-allocate 
	memory, causing memory leaks, or accessing memory incorrectly which in turn 
	causes segmentation faults. Programs written for .NET eschew this class of 
	errors completely.
	
	The CLR executes programs that have been compiled to the Common Intermediate 
	Language (CIL) format. It is a stack based virtual machine, which means it has
	an evaluation stack where the CIL bytecodes are evaluated. An illustrative 
	snippet of C\# code and it's corresponding CIL is shown in 
	Figure \ref{fig:cil}. The CIL bytecodes generally fall into four categories:
		
	\begin{enumerate}
		\item \textbf{Load items onto the stack}. These include bytecodes to load
		integers, floating point numbers, strings, object references, local variables
		or class fields onto the evaluation stack. These bytecodes take one argument
		each, the item to be loaded onto the stack.
		
		\item \textbf{Store stack items into variables/fields}. These bytecodes take
		the top item on the stack and store it in a local variable, global variable
		or class member variable. They take one argument, which is a reference to the
		variable to store in.
		
		\item \textbf{Call functions}. These take an argument, that is a reference to
		the function to call, and then call it with the parameters that are currently 
		on the evaluation stack.
			
		\item \textbf{Operate on stack items}. These bytecodes usually do nottake any
		arguments, they simply use values on the stack and push results back onto the 
		stack. Examples of these are bytecodes that add, multiply or divide the top 
		two values on the stack, and then push the result back onto the stack.
		
	\end{enumerate}
	
	At the time of execution, the CLR generates native code for the particular 
	machine architecture that it is running on from the CIL bytecodes, this is 
	referred to as Just-in-time compiling, or JIT compiling. A more detailed 
	explanation of that process is outside the scope of this paper, but detailed
	information can be found in \ref{NEEDREF}.
	
\lstset{language=CSharp}
\lstset{commentstyle=\textit}
\begin{lstlisting}[frame=trbl]
using System;
namespace CodeGenDemo {
    class Program {
        static void Main(string[] args) {
            Console.WriteLine("Hello world");
        }
    }
}

-------------------------------------------------
.class private auto ansi beforefieldinit CodeGenDemo.Program
       extends [mscorlib]System.Object
{
  .method private hidebysig static void  Main(string[] args) cil managed
  {
    .entrypoint
    // Code size       20 (0x14)
    .maxstack  8
    IL_0000:  nop
    IL_0001:  ldstr      "Hello world"
    IL_0006:  call       void [mscorlib]System.Console::WriteLine(string)
    IL_0013:  ret
  } // end of method Program::Main
\end{lstlisting}
  
