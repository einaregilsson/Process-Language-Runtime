\chapter{KLAIM Implementation}\label{ch:klaim}

	In this chapter we look at the second language implemented using the PLR, 
	the Kernel Language for Agents Interaction and Mobility, or KLAIM. Unlike 
	the CCS implementation, the PLR does not contain all the constructs needed 
	for an implementation of KLAIM, so this chapter is a case study in how the 
	PLR can be extended for use with other languages than CCS.
	
\section{Overview}
	
	KLAIM is a language introduced in 1998 in \cite{klaim}, it's main purpose is 
	to model mobile agents in a distributed environment. It derives many of its 
	constructs from process algebra, but it is also heavily influenced by 
	Linda \cite{linda1, linda2}, a distributed computing solution from which it 
	borrows the concept of \textit{tuple spaces}. A tuple space is a collection 
	of tuples of data, these tuples can be read and removed from the tuple space 
	or new tuples can be added to it. Selecting tuples to read is done by means 
	of pattern matching. In KLAIM, processes run in different 
	\textit{localities}, each of which contains zero or more processes 
	and its own tuple space. The actions performed by the processes input, 
	output and read tuples of data from these tuple spaces. Unlike CCS, where 
	processes synchronized with each other through channels, in KLAIM the way 
	processes communicate is strictly by adding and retrieving data from tuple 
	spaces of different localities. 
	
	The concept of data stores (or tuple spaces) and actions which operate on 
	them is something that is not built into the PLR. KLAIM does however contain 
	many constructs which are a part of the PLR, namely parallel composition, 
	non-deterministic choice and action prefixing (albeit with different type of 
	actions than those built into the PLR). It also contains a fairly common 
	process algebra construct which is not part of the PLR, 
	\textit{replication}. These additional features make KLAIM an ideal 
	candidate to use as a test of how easily the PLR can be extended to 
	accommodate other languages than CCS.
	
	\subsection{The implemented subset of KLAIM}
	
	The implementation of KLAIM described in this chapter is only for a subset 
	of the full language. In particular the \textbf{in}, \textbf{out} and 
	\textbf{read} actions are implemented while the \textbf{eval} and 
	\textbf{newloc} actions are not. The implementation also does not support 
	process constants, processes are defined directly in the \textit{net} and so 
	cannot turn into other processes. The subset of KLAIM implemented here is 
	the same as that described in \cite{aspectk, giordano}, both of which are
	projects developed at the Technical University of Denmark that focus on an 
	aspect-oriented version of KLAIM. Section~\ref{sec:klaim_syntax} only shows 
	syntax and semantic for the subset being used, for a description of the full 
	KLAIM language we refer to \cite{klaim}. 
	
	KLAIMS stated purpose is to be a programming language for programming mobile 
	agents in a distributed environment. However in this implementation all 
	processes in the system are running on the same computer, and in the same 
	(operating system) process. The distributed part of it is purely conceptual. 
	As such, this implementation can be seen more as a simulation of how KLAIM 
	works rather than an implementation ready to be used for actual 
	applications. Examples of other implementations of KLAIM are given in the 
	next section.
		
	\subsection{Other implementations of KLAIM}
		
	Noteworthy implementations of KLAIM include KLAVA\cite{klava}, which is a 
	Java library representing the KLAIM constructs as Java classes, and X-Klaim 
	\cite{xklaim}, a compiler for a superset of KLAIM whose output is Java 
	source code that uses the KLAVA library. A different approach is taken in 
	\cite{giordano} where a virtual machine is developed specifically for 
	AspectK, an aspect-oriented version of KLAIM. A further explanation of these 
	implementations and a comparison with the PLR is given in 
	Section~\ref{sec:related_work}. 

\section{Syntax and semantics}\label{sec:klaim_syntax}
	
	\subsection{Syntax}
	A KLAIM net is made up of located processes and located tuples. We use $N$ 
	for a net and the composition of nodes of the net is given with the 
	$\mid\mid$ operator. We use $P$ and $Q$ for processes and $a$ for actions.
	$x$ is used as a generic variable name, $!x$ represents the binding of a 
	value to variable $x$ and $e$ represents an arithmetic 
	expression. $l$ is a locality constant while $\ell$ can refer to either a 
	locality constant or a variable. $t$ represents a tuple of 
	elements, which can be constants, variables and variable bindings. 
	Located tuples are written as $l::\langle t\rangle$ and 
	located processes as $l::P$. Parallel composition and non-determenistic 
	choice is represented the same way as in CCS, with $+$ and $\mid$ 
	respectively. The replication construct is represented by an asterisk, $*$, 
	immediately preceding a process. Action prefixing is written as $a . P$, and 
	the nil process as \textbf{\textsf{nil}}. Papers on KLAIM traditionally 
	allow the omission of the \textbf{\textbf{nil}} at the end of a process term 
	and so does this implementation, $\mathbf{out}(t)@l . \mathbf{in}(t)@l$ is 
	equivalent to $\mathbf{out}(t)@l . \mathbf{in}(t)@l . \mathbf{nil}$. 
	Figure~\ref{fig:klaim_syntax} shows an overview of the syntax. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[t]
\begin{ARRAY}{r c l l}
		  N & ::= & N_1 \mid\mid\ N_2 & \mathrm{(Net\ composition)}\vspace{3pt}\\
			    & \mid & l::\langle t \rangle & \mathrm{(Located\ tuple)}\vspace{3pt}\\
			    & \mid & l::P & \mathrm{(Located\ process)}\vspace{10pt}\\

			P & ::= & \mathbf{nil} & \mathrm{(Nil\ process)}\vspace{3pt}\\
			    & \mid & a . P & \mathrm{(Action\ prefixing)}\vspace{3pt} \\
			    & \mid & P \mid Q & \mathrm{(Parallel\ composition)}\vspace{3pt}\\
			    & \mid & P + Q & \mathrm{(Nondeterministic\ choice)}\vspace{3pt}\\
			    & \mid & *P  & \mathrm{(Replication)}\vspace{10pt}\\

			a & ::= & \mathbf{out}(t)@\ell\ & \mathrm{(Add\ tuple\ to\ the\ \ell\  tuple\ space)}\vspace{3pt}\\
			
			    & \mid\ & \mathbf{in}(t)@\ell\ & \mathrm{(Remove\ tuple\ from\ the\ \ell\ tuple\ space)}\vspace{3pt}\\

			    & \mid\ & \mathbf{read}(t)@\ell\ & \mathrm{(Read\ tuple\ from\ the\ \ell\ tuple\ space)}\vspace{10pt}\\
			    
			t & ::= & e & \mathrm{(Expression)} \vspace{3pt}\\
			  & \mid & \ell & \mathrm{(Locality\ constant\ or\ variable)} \vspace{3pt}\\
			  & \mid & x & \mathrm{(Variable)} \vspace{3pt}\\
			  & \mid & !x & \mathrm{(The\ binding\ of\ variable\ x)} \vspace{3pt}\\
			  & \mid & t_1,t_2 & \mathrm{(Sequence\ of\ tuple\ elements)} \vspace{3pt}\\
\end{ARRAY}
\caption{KLAIM Nets and processes syntax}
\label{fig:klaim_syntax}
\end{figure}
	
	\subsection{Structural Congruence}
	Figure~\ref{fig:klaim_structural_congruence} shows the structural congruence 
	of net composition, parallel composition and replication. The most 
	interesting thing here for the implementation is that all processes located 
	at the same locality should be treated as a parallel composition process. 
	The replication construct also poses some interesting challenges since
	effectively there can be endless instances of a replicated process. 
	Obviously this is unfeasible for implementation so some solution needs to be 
	worked out that simulates this.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%Structure equivalence
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[t]
\begin{ARRAY}{l@{\qquad\qquad}l}
l:: P_1 \ppar P_2 \equiv l::P_1 \netpar l::P_2 &
l ::\ * P  \equiv l ::\ P \ppar\ * P
\\[2ex]
\Inference{N_1 \equiv N_2}{N \netpar N_1 \equiv N \netpar N_2}
\end{ARRAY}
\caption{KLAIM Structural Congruence.}
\label{fig:klaim_structural_congruence}
\end{figure}


\subsection{Semantics}

%%Semantics
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[t]
\begin{ARRAY}{ll}
%%Out
l_1::\mathbf{out}(t)@l_2.P \rightarrow
l_1::P \netpar l_2::\langle t \rangle
%%In
\\[1ex]
%\begin{array}{r}
l_1::\mathbf{in}(t)@l_2.P \netpar
l_2::\langle t' \rangle \rightarrow l_1::P\theta
 & \hbox{if $match(t;t')= \theta$}
%\end{array}
%%Read
\\[1ex]
%\begin{array}{r}
l_1::\mathbf{read}(t)@l_2.P \netpar
l_2::\langle t' \rangle \rightarrow  l_1::P
\theta \netpar l_2::\langle t' \rangle & 
\hbox{if $match(t;t')= \theta$}
%\end{array}
\\[2ex]
\Inference{ N_1 \rightarrow N_1'}{ N_1 \netpar
N_2 \rightarrow  N_1' \netpar N_2}
\hfill
\hfill
\hfill
\hspace{10pt}
\Inference{N \equiv N'\quad  N' \rightarrow N'' \quad N'' \equiv
N'''}{ N \rightarrow N'''}
\end{ARRAY}
\caption{KLAIM Reaction Semantics (on closed nets).}
\label{fig:klaim_semantics}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


	Since KLAIM has actions that are quite different from those of CCS, we now 
	look closer at those actions. As stated before the operations implemented 
	are \textbf{in}, \textbf{out} and \textbf{read}. The reaction semantics for 
	these operations are shown in Figure~\ref{fig:klaim_semantics}, below is an 
	informal description with examples.
	
	The \textbf{out} operation adds a tuple to the tuplespace of a particular 
	locality. The operation $\mathbf{out}\mathsf{(John,\ Sally)@BusStop}$ adds 
	the tuple $\langle$\textsf{John, Sally}$\rangle$ to the tuplespace at the 
	\textsf{BusStop} locality. The \textbf{out} operation is asynchronous and 
	can never block. This is a big difference from the synchronization actions 
	of CCS which are always dependent on other processes. A KLAIM process 
	composed entirely of \textbf{out} actions can run all the way through 
	without ever stopping because of something other processes are doing.
	
	The \textbf{in} operation removes a tuple from a particular locality's 
	tuplespace if it matches a certain \textit{template}. The template is a 
	tuple which can contain constants, variables and variable bindings. For 
	example the operation $\mathbf{in}\mathsf{(John,\ !other)@BusStop}$ will 
	look in the \textsf{BusStop} locality's tuplespace for a matching tuple, and 
	if it finds one it will be removed and a value bound to the \textsf{other} 
	variable.	The details of matching of templates to tuples is further 
	explained in Section~\ref{klaim_pattern_matching}. One \textbf{in} operation 
	only removes one tuple, if more than one tuple match the pattern then one of 
	them is randomly selected. If no matching tuple exists at the tuplespace the 
	operation will block until one becomes available.

	The \textbf{read} operation is very similar to the \textbf{in} operation; 
	essentially it behaves exactly the same way, except that it does not remove 
	a matching tuple, it just binds values to variables.

\subsection{Pattern matching against tuples}\label{klaim_pattern_matching}
	Figure~\ref{fig:klaim_matching} shows the \textit{match} function used by 
	both the \textbf{in} and \textbf{read} operations. Essentially it works by 
	selecting a tuple from the tuple space that fulfills these conditions:
	
	\begin{enumerate}
		\item The operation tuple $t$ contains the same number of elements as the 
		candidate tuple $t'$ from the tuple space.
		
		\item In every index position $i$ in $t$ which is not a variable binding, 
		the element at $t_i$ is equal to the element at that position in $t$. To 
		put it more succinctly, $t_i$ = $t'_i$ for all $i$ where $t_i$ is not a 
		variable binding.
	\end{enumerate}
	
	If a tuple does not fulfill these conditions it is not selected. If no tuple 
	in the tuple space fulfills the conditions then the process is blocked until 
	the tuplespace acquires such a tuple. The result of the \textit{match} 
	function is a binding of variable names to values according to the variables
	position in the tuple. To give an example of this, suppose we have the 
	following net:
	\begin{verbatim}
		   YellowPages::<John, 352468> 
		   || Sally::read(John, !phonenr)@YellowPages
	\end{verbatim}
	
	The process at locality \textsf{Sally} will match the tuple of the read 
	operation, \textsf{(John, !phonenr)} against the tuple 
	\textsf{$\langle$John, 352468$\rangle$} at the \textsf{YellowPages} 
	locality. Since the first element matches, and the only other element is a 
	variable binding, the tuples match and the value 352468 is bound to the 
	variable \textsf{phonenr} that can then be used in the continuation of the 
	process at locality \textsf{Sally}. 
	
	
%%match
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[t]
\begin{ARRAY}{l}
match(\langle\rangle;\langle\rangle) = id
\\[2ex]
match(\langle t_{1},\cdots,t_k\rangle;\langle t'_1,\cdots,t'_k\rangle)
= \begin{array}[t]{l}
\hbox{let}\ \theta = \hbox{case}\ t_1 \hbox{of}\\
\qquad\qquad \ell:\ \ \hbox{if $t_1 = t'_1$ then $id$ else $fail$}\\
\qquad\qquad !x:\ \ [t'_1/x]\\
\hbox{in } \theta \circ match(\langle
t_2,\cdots,t_k\rangle;\langle t'_2,\cdots,t'_k\rangle)
\end{array}
\end{ARRAY}
\caption{KLAIM Pattern Matching of Templates against Tuples.}
\label{fig:klaim_matching}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%	


\section{Implementation}

\subsection{Class overview}
	
\section{Summary}
