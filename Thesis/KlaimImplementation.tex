\chapter{KLAIM Implementation}\label{ch:klaim}

	In this chapter we look at the second language implemented using the PLR, 
	the Kernel Language for Agents Interaction and Mobility, or KLAIM. Unlike 
	the CCS implementation, the PLR does not contain all the constructs needed 
	for an implementation of KLAIM, so this chapter is a case study in how the 
	PLR can be extended for use with other languages than CCS.
	
\section{Overview}
	
	KLAIM is a language introduced in 1998 in \cite{klaim}, it's main purpose is 
	to model mobile agents in a distributed environment. It derives many of its 
	constructs from process algebra, but it is also heavily influenced by 
	Linda \cite{linda1, linda2}, a distributed computing solution from which it 
	borrows the concept of \textit{tuple spaces}. A tuple space is a collection 
	of tuples of data, these tuples can be read and removed from the tuple space 
	or new tuples can be added to it. Selecting tuples to read is done by means 
	of pattern matching. In KLAIM, processes run in different 
	\textit{localities}, each of which contains zero or more processes 
	and its own tuple space. The actions performed by the processes input, 
	output and read tuples of data from these tuple spaces. Unlike CCS, where 
	processes synchronized with each other through channels, in KLAIM the way 
	processes communicate is strictly by adding and retrieving data from tuple 
	spaces of different localities. 
	
	The concept of data stores (or tuple spaces) and actions which operate on 
	them is something that is not built into the PLR. KLAIM does however contain 
	many constructs which are a part of the PLR, namely parallel composition, 
	non-deterministic choice and action prefixing (albeit with different type of 
	actions than those built into the PLR). It also contains a fairly common 
	process algebra construct which is not part of the PLR, 
	\textit{replication}. These additional features make KLAIM an ideal 
	candidate to use as a test of how easily the PLR can be extended to 
	accommodate other languages than CCS.
	
	\subsection{The implemented subset of KLAIM}
	
	The implementation of KLAIM described in this chapter is only for a subset 
	of the full language. In particular the \textbf{in}, \textbf{out} and 
	\textbf{read} actions are implemented while the \textbf{eval} and 
	\textbf{newloc} actions are not. The implementation also does not support 
	process constants, processes are defined directly in the \textit{net} and so 
	cannot turn into other processes. The subset of KLAIM implemented here is 
	the same as that described in \cite{aspectk, giordano}, both of which are
	projects developed at the Technical University of Denmark that focus on an 
	aspect-oriented version of KLAIM. Section~\ref{sec:klaim_syntax} only shows 
	syntax and semantic for the subset being used, for a description of the full 
	KLAIM language we refer to \cite{klaim}. 
	
	KLAIMS stated purpose is to be a programming language for programming mobile 
	agents in a distributed environment. However in this implementation all 
	processes in the system are running on the same computer, and in the same 
	(operating system) process. The distributed part of it is purely conceptual. 
	As such, this implementation can be seen more as a simulation of how KLAIM 
	works rather than an implementation ready to be used for actual 
	applications. Examples of other implementations of KLAIM are given in the 
	next section.
		
	\subsection{Other implementations of KLAIM}
		
	Noteworthy implementations of KLAIM include KLAVA\cite{klava}, which is a 
	Java library representing the KLAIM constructs as Java classes, and X-Klaim 
	\cite{xklaim}, a compiler for a superset of KLAIM whose output is Java 
	source code that uses the KLAVA library. A different approach is taken in 
	\cite{giordano} where a virtual machine is developed specifically for 
	AspectK, an aspect-oriented version of KLAIM. A further explanation of these 
	implementations and a comparison with the PLR is given in 
	Section~\ref{sec:related_work}. 

\section{Syntax and semantics}\label{sec:klaim_syntax}
	
	\subsection{Syntax}
	A KLAIM net is made up of located processes and located tuples. We use $N$ 
	for a net and the composition of nodes of the net is given with the 
	$\mid\mid$ operator. We use $P$ and $Q$ for processes and $a$ for actions.
	$x$ is used as a generic variable name, $!x$ represents the binding of a 
	value to variable $x$ and $e$ represents an arithmetic 
	expression. $l$ is a locality constant while $\ell$ can refer to either a 
	locality constant or a variable. $t$ represents a tuple of 
	elements, which can be constants, variables and variable bindings. 
	Located tuples are written as $l::\langle t\rangle$ and 
	located processes as $l::P$. Parallel composition and non-determenistic 
	choice is represented the same way as in CCS, with $+$ and $\mid$ 
	respectively. The replication construct is represented by an asterisk, $*$, 
	immediately preceding a process. Action prefixing is written as $a . P$, and 
	the nil process as \textbf{\textsf{nil}}. Papers on KLAIM traditionally 
	allow the omission of the \textbf{\textbf{nil}} at the end of a process term 
	and so does this implementation, $\mathbf{out}(t)@l . \mathbf{in}(t)@l$ is 
	equivalent to $\mathbf{out}(t)@l . \mathbf{in}(t)@l . \mathbf{nil}$. 
	Figure~\ref{fig:klaim_syntax} shows an overview of the syntax. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[t]
\begin{ARRAY}{r c l l}
		  N & ::= & N_1 \mid\mid\ N_2 & \mathrm{(Net\ composition)}\vspace{3pt}\\
			    & \mid & l::\langle t \rangle & \mathrm{(Located\ tuple)}\vspace{3pt}\\
			    & \mid & l::P & \mathrm{(Located\ process)}\vspace{10pt}\\

			P & ::= & \mathbf{nil} & \mathrm{(Nil\ process)}\vspace{3pt}\\
			    & \mid & a . P & \mathrm{(Action\ prefixing)}\vspace{3pt} \\
			    & \mid & P \mid Q & \mathrm{(Parallel\ composition)}\vspace{3pt}\\
			    & \mid & P + Q & \mathrm{(Nondeterministic\ choice)}\vspace{3pt}\\
			    & \mid & *P  & \mathrm{(Replication)}\vspace{10pt}\\

			a & ::= & \mathbf{out}(t)@\ell\ & \mathrm{(Add\ tuple\ to\ the\ \ell\  tuple\ space)}\vspace{3pt}\\
			
			    & \mid\ & \mathbf{in}(t)@\ell\ & \mathrm{(Remove\ tuple\ from\ the\ \ell\ tuple\ space)}\vspace{3pt}\\

			    & \mid\ & \mathbf{read}(t)@\ell\ & \mathrm{(Read\ tuple\ from\ the\ \ell\ tuple\ space)}\vspace{10pt}\\
			    
			t & ::= & e & \mathrm{(Expression)} \vspace{3pt}\\
			  & \mid & \ell & \mathrm{(Locality\ constant\ or\ variable)} \vspace{3pt}\\
			  & \mid & x & \mathrm{(Variable)} \vspace{3pt}\\
			  & \mid & !x & \mathrm{(The\ binding\ of\ variable\ x)} \vspace{3pt}\\
			  & \mid & t_1,t_2 & \mathrm{(Sequence\ of\ tuple\ elements)} \vspace{3pt}\\
\end{ARRAY}
\caption{KLAIM Nets and processes syntax}
\label{fig:klaim_syntax}
\end{figure}
	
	\subsection{Structural Congruence}
	Figure~\ref{fig:klaim_structural_congruence} shows the structural congruence 
	of net composition, parallel composition and replication. The most 
	interesting thing here for the implementation is that all processes located 
	at the same locality should be treated as a parallel composition process. 
	The replication construct also poses some interesting challenges since
	effectively there can be endless instances of a replicated process. 
	Obviously this is unfeasible for implementation so some solution needs to be 
	worked out that simulates this.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%Structure equivalence
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[t]
\begin{ARRAY}{l@{\qquad\qquad}l}
l:: P_1 \ppar P_2 \equiv l::P_1 \netpar l::P_2 &
l ::\ * P  \equiv l ::\ P \ppar\ * P
\\[2ex]
\Inference{N_1 \equiv N_2}{N \netpar N_1 \equiv N \netpar N_2}
\end{ARRAY}
\caption{KLAIM Structural Congruence.}
\label{fig:klaim_structural_congruence}
\end{figure}


\subsection{Semantics}

%%Semantics
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[t]
\begin{ARRAY}{ll}
%%Out
l_1::\mathbf{out}(t)@l_2.P \rightarrow
l_1::P \netpar l_2::\langle t \rangle
%%In
\\[1ex]
%\begin{array}{r}
l_1::\mathbf{in}(t)@l_2.P \netpar
l_2::\langle t' \rangle \rightarrow l_1::P\theta
 & \hbox{if $match(t;t')= \theta$}
%\end{array}
%%Read
\\[1ex]
%\begin{array}{r}
l_1::\mathbf{read}(t)@l_2.P \netpar
l_2::\langle t' \rangle \rightarrow  l_1::P
\theta \netpar l_2::\langle t' \rangle & 
\hbox{if $match(t;t')= \theta$}
%\end{array}
\\[2ex]
\Inference{ N_1 \rightarrow N_1'}{ N_1 \netpar
N_2 \rightarrow  N_1' \netpar N_2}
\hfill
\hfill
\hfill
\hspace{10pt}
\Inference{N \equiv N'\quad  N' \rightarrow N'' \quad N'' \equiv
N'''}{ N \rightarrow N'''}
\end{ARRAY}
\caption{KLAIM Reaction Semantics (on closed nets).}
\label{fig:klaim_semantics}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


	Since KLAIM has actions that are quite different from those of CCS, we now 
	look closer at those actions. As stated before the operations implemented 
	are \textbf{in}, \textbf{out} and \textbf{read}. The reaction semantics for 
	these operations are shown in Figure~\ref{fig:klaim_semantics}, below is an 
	informal description with examples.
	
	The \textbf{out} operation adds a tuple to the tuplespace of a particular 
	locality. The operation $\mathbf{out}\mathsf{(John,\ Sally)@BusStop}$ adds 
	the tuple $\langle$\textsf{John, Sally}$\rangle$ to the tuplespace at the 
	\textsf{BusStop} locality. The \textbf{out} operation is asynchronous and 
	can never block. This is a big difference from the synchronization actions 
	of CCS which are always dependent on other processes. A KLAIM process 
	composed entirely of \textbf{out} actions can run all the way through 
	without ever stopping because of something other processes are doing.
	
	The \textbf{in} operation removes a tuple from a particular locality's 
	tuplespace if it matches a certain \textit{template}. The template is a 
	tuple which can contain constants, variables and variable bindings. For 
	example the operation $\mathbf{in}\mathsf{(John,\ !other)@BusStop}$ will 
	look in the \textsf{BusStop} locality's tuplespace for a matching tuple, and 
	if it finds one it will be removed and a value bound to the \textsf{other} 
	variable.	The details of matching of templates to tuples is further 
	explained in Section~\ref{klaim_pattern_matching}. One \textbf{in} operation 
	only removes one tuple, if more than one tuple match the pattern then one of 
	them is randomly selected. If no matching tuple exists at the tuplespace the 
	operation will block until one becomes available.

	The \textbf{read} operation is very similar to the \textbf{in} operation; 
	essentially it behaves exactly the same way, except that it does not remove 
	a matching tuple, it just binds values to variables.

\subsection{Pattern matching against tuples}\label{klaim_pattern_matching}
	Figure~\ref{fig:klaim_matching} shows the \textit{match} function used by 
	both the \textbf{in} and \textbf{read} operations. Essentially it works by 
	selecting a tuple from the tuple space that fulfills these conditions:
	
	\begin{enumerate}
		\item The operation tuple $t$ contains the same number of elements as the 
		candidate tuple $t'$ from the tuple space.
		
		\item In every index position $i$ in $t$ which is not a variable binding, 
		the element at $t_i$ is equal to the element at that position in $t$. To 
		put it more succinctly, $t_i$ = $t'_i$ for all $i$ where $t_i$ is not a 
		variable binding.
	\end{enumerate}
	
	If a tuple does not fulfill these conditions it is not selected. If no tuple 
	in the tuple space fulfills the conditions then the process is blocked until 
	the tuplespace acquires such a tuple. The result of the \textit{match} 
	function is a binding of variable names to values according to the variables
	position in the tuple. To give an example of this, suppose we have the 
	following net:
	\begin{verbatim}
		   YellowPages::<John, 352468> 
		   || Sally::read(John, !phonenr)@YellowPages
	\end{verbatim}
	
	The process at locality \textsf{Sally} will match the tuple of the read 
	operation, \textsf{(John, !phonenr)} against the tuple 
	\textsf{$\langle$John, 352468$\rangle$} at the \textsf{YellowPages} 
	locality. Since the first element matches, and the only other element is a 
	variable binding, the tuples match and the value 352468 is bound to the 
	variable \textsf{phonenr} that can then be used in the continuation of the 
	process at locality \textsf{Sally}. 
	
	
%%match
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[t]
\begin{ARRAY}{l}
match(\langle\rangle;\langle\rangle) = id
\\[2ex]
match(\langle t_{1},\cdots,t_k\rangle;\langle t'_1,\cdots,t'_k\rangle)
= \begin{array}[t]{l}
\hbox{let}\ \theta = \hbox{case}\ t_1 \hbox{of}\\
\qquad\qquad \ell:\ \ \hbox{if $t_1 = t'_1$ then $id$ else $fail$}\\
\qquad\qquad !x:\ \ [t'_1/x]\\
\hbox{in } \theta \circ match(\langle
t_2,\cdots,t_k\rangle;\langle t'_2,\cdots,t'_k\rangle)
\end{array}
\end{ARRAY}
\caption{KLAIM Pattern Matching of Templates against Tuples.}
\label{fig:klaim_matching}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%	


\section{Implementation}
	The KLAIM implementation was written in C\# using Visual Studio 2008 as the 
	development environment. It implements the subset of KLAIM described in  
	Section~\ref{sec:klaim_syntax}. KLAIM contains a number of features not 
	available in the PLR, some of these were implemented as syntax tree nodes 
	for the PLR syntax tree while others were implemented in a KLAIM runtime 
	library. The PLR syntax tree nodes for action prefixing, the nil process, 
	parallel composition and nondeterministic choice were used without 
	modification. Expression nodes (constants, variables, arithmetic 
	expressions) could also be re-used so right away the implementation had a 
	number of building blocks ready for use. The main focus was then on the 
	things that differentiate KLAIM from other process languages: its syntax, 
	replication and tuple spaces with their associated \textbf{in}, \textbf{out} 
	and \textbf{read} actions. Each of these is described in the following 
	sections.
	
\subsection{Replication}
	
	Replication is a construct which was quite tricky to implement 
	according to specification. As we saw in 
	Figure~\ref{fig:klaim_structural_congruence} the congruence of replication 
	is defined as
	\begin{center}$l::*P \equiv l::P \mid *P$\end{center}
	so essentially a replicated process is equal to infinite instances of that 
	process running in parallel. For obvious reasons the implementation can not 
	create infinite instances so another solution was needed that mimicked this 
	behavior as closely as possibly. A number of possible approaches were 
	considered for this problem.
	
	The naive approach is to let the replicated process simply keep
	spawning new instances of itself endlessly. The way this could be 
	implemented is by having a small delay between each instantiation of
	the process, to avoid using up all available memory instantly. This
	still has the problem of overshadowing everything else that is going
	on in the system. Consider the case where the first action of a 
	replicated process is an \textbf{out} action, e.g. 
	$\mathbf{out}(X,Y,Z)@Loc$. Over time the $Loc$ locality will fill up
	with $\langle X,Y,Z \rangle$ tuples, making visualization of the net 
	difficult as well as following what actions are happening. This could be 
	partially alleviated by showing tuples that are identical as just one tuple 
	with a number indicating how many of them there are, but that is still a
	hack to cover for an inadequate solution.
		
	Another approach could be to change the semantics of replication
	to that of repetition. That is, instead of defining a replicated
	process as
	\begin{center}$l ::\ *P  \equiv l ::\ P \ppar *P$\end{center}
	it could be defined as
	\begin{center}$l ::\ *P  \equiv l ::\ P .* P$\end{center}
	This is certainly possible to implement and is somewhat similar to 
	replication. There are many ways in which it is different though and
	some hard questions are raised. What should happen to variables that
	are bound in $P$, are their values carried on into the next iteration of 
	$P$, or does the next iteration start with the original values (or lack
	of values) of those variables? Another concern is that if $P$ blocks on
	an action at any point then no new instances of $P$ are spawned until the
	original instance of $P$ continues and finishes. 
		
	The third approach would be to replace infinity with a set number. Instead
	of having infinite instances of $P$ the system would instead have $n$ 
	instances, and $n$ could be configured, for instance with a command line 
	switch. The problem with this is that it turns a behavior that is supposed
	to continue forever into a behavior that ends at a particular time, that is 
	when all $n$ instances have finished.
	
	A fourth approach is to spawn new instances of the process only 
	when needed so that it appears as though there is an infinite amount. This
	is the approach that was ultimately chosen and is implemented in the KLAIM
	compiler. The objective is to simulate infinite processes with as few 
	processes as possible, in order to do that it is important to realize where
	infinite processes give the same result as a single process:
	
	\begin{enumerate}
		\item When a process $P$ is blocked doing an \textbf{in} action, it does 
		not matter whether one instance is blocked or many. The only difference is 
		when an instance becomes unblocked, if there was just one to begin with 
		then no instance is blocked at that action any longer, but if there were 
		$n$ instances blocked there are now $n-1$ instances blocked. This implies
		that if there was just one instance blocked, and another instance was 
		spawned as the first instance unblocked then that would give the same 
		result as having infinite instances blocked. (This conveniently leaves
		out the possibility that each instance might have different values in its 
		bound variables, this will be discussed later).
	
		\item Since \textbf{read} actions do not change the state of tuple spaces
		in any way, it can be assumed that having one instance of $P$ perform a
		\textbf {read} action or having infinite instances of $P$ perform the 
		action would have the same effect on the state of the tuple spaces, that 
		is, not affect them at all. (Again, difference in variable values is not 
		considered).
		
		\item Mimicking the \textbf{out} operation is a little more tricky than 
		the other two. Clearly there is a difference between one process 
		performing an \textbf{out} action and multiple processes performing the 
		same action. If multiple processes perform the action then there will be 
		multiple copies of the same tuple (or rather multiple tuples with the same 
		value) at the tuplespace that the action was performed at (again, ignoring 
		possible differences in variable values). So from the perspective of 
		looking at the tuplespace there clearly is a difference. However, if we 
		consider how this affects the overall system, the behaviour of other 
		processes, then the difference is only apparent when other processes start 
		removing those tuples from the tuplespace. If only one process outputs a 
		tuple $t$ then the next process that tries to remove it will be successful 
		but any subsequent process that tries to remove it will block. However if 
		there were multiple copies of $t$ then no process trying to remove it 
		would block. A possible way to mimic this would be to track each tuple 
		that is output by a replicated process, and if that tuple is removed by 
		another process then a new instance of the replicated process can be 
		spawned which will output a new identical tuple $t$ at the tuplespace, 
		allowing more processes to sucessfully perform an \textbf{in} action at 
		that tuplespace.

	\end{enumerate}
	
	The biggest flaw with this approach is the fact that it does not take 
	variables into consideration. When one or more tuples match an \textbf{in} 
	or \textbf{read} operation, a tuple is selected nondeterministically. That
	means that two processes that perform the actions $ \mathbf{in}(!x)@Loc_1 . 
	\mathbf{out}(x)@Loc_2 $ might not be outputting the same tuple at $Loc_2$ if
	$x$ was bound to different values at $Loc_1$ during the \textbf{in} action. 
	So this approach will always be an approximation, it will never conform 
	exactly to the formal semantics of replication, although it will be close
	enough for most cases. 
	
	To get even closer to the actual replication semantics the KLAIM compiler 
	allows the user to specify how many instances of a replicated process are 
	created initially, as in the third approach described above. The default is 
	to create just one process initially and spawn others as needed when the 
	process removes tuples, or tuples that it generated are removed, but this 
	can be overridden to set the initial number to any positive number $n$. This 
	allows for creating for instance five initial instances of the replicated 
	process, and then spawning new instances as the initial five instances 
	progress on their path. The goal is that at every stage in the replicated 
	process there should always (or as often as possible) be at least one 
	instance of the process. Combining the limited number of instances with
	spawning new instances as needed does not overflow the system, and gives
	the user the ability to choose how many instances are needed to accurately
	model the system he is creating.
	
	Implementing this was done by having the replication process be one class 
	and the inner process, containing the actions, be another class. The 
	replication class $R$ when invoked just creates new instances of the inner 
	class, $Q$. It passes a reference to itself to $Q$ and when $Q$ performs an 
	\textbf{in} action then it notifies $R$ which can then spawn a new 
	instance of $Q$. When $Q$ performs an \textbf{out} action then it attaches 
	its reference	to $R$ to the tuple being output. When another process $P$
	eventually removes that tuple from a tuplespace, it will then check whether
	the tuple has a reference to a replication process, and if so $P$ will notify
	$R$ that a tuple generated by $Q$ was removed and $R$ can then once again 
	spawn a new instance of $Q$. To summarize:
	
	\begin{itemize}
		\item A replicated process initially creates 1-n instances of itself, 
		according to user preference.
		
		\item When the process removes a tuple from a tuple space, a new instance
		of it is created.
		
		\item When the process has created a tuple with an \textbf{out} operation, 
		and that tuple is removed by another process, then a new instance of the 
		replicated process is created.
	\end{itemize}

\subsection{Tuple spaces}

	The tuple spaces of KLAIM are implemented in the KLAIM runtime library. The 
	library consists of just four classes, \textsf{Net}, \textsf{Locality}, 
	\textsf{Tuple} and \textsf{KLAIMException}. Figure~\ref{fig:klaim_runtime} 
	shows a class diagram of the runtime library.

	\begin{figure}[h!]
		\centering
		\includegraphics[scale=0.8]{klaim_runtime.jpg}
		\caption{KLAIM runtime library classes}
		\label{fig:klaim_runtime}
	\end{figure}
	
	\begin{itemize}
	
	\item The \textsf{Net} class represents the entire program, or net, being 
	executed. It does very little itself and only contains a collection of 
	\textsf{Locality} instances as well as methods to add and delete them. 
	
	\item The \textsf{Locality} class has a name and a collection of tuples, 
	which 
	represents its tuple space. The \textbf{in}, \textbf{out} and \textbf{read} 
	actions are implemented as member methods of this class, this seemed a 
	natural fit since this class holds the tuples. It also contains some 
	convenience methods not available to KLAIM itself, such as methods to check 
	in a non-blocking way if a tuple exists and retrieve a random tuple from the 
	tuple space.

	\item The \textsf{Tuple} class represents a tuple. As such it holds an 
	ordered collection of items (integers or strings). It also contains the 
	\textsf{Matches} method, this method implements the template matching 
	against tuples described in Section~\ref{klaim_pattern_matching}.
	
	\item \textsf{KLAIMException} is a trivial class which just inherits from 
	\textsf{System.Exception} and whose only purpose is to allow callers to 
	catch a KLAIM specific exception instead of a general one.
	
	\end{itemize}
	
	As seen in these class descriptions, the implementation of tuple spaces is 
	handled by these four classes, \textsf{Net} holds \textsf{Locality} 
	instances, they hold collections of \textsf{Tuple} instances and the methods 
	to access them, and the \textsf{Tuple}'s implement the pattern matching.
	
	The tuples initially contained in each locality's tuple space need to 
	somehow be put in their place before execution of the net starts. This is an 
	activity that does not really fit into the abstract syntax tree in any 
	particular place. To accomplish this the KLAIM compiler subscribes to the 
	event \textsf{MainMethodStart} of the \textsf{ProcessSystem} object, which 
	is the root node of the syntax tree. Then when the syntax tree is compiling 
	itself and is starting to compile the entry method of the program, it raises 
	this event and passes as an event argument the \textsf{CompileContext} 
	class. It contains an initialized \textsf{ILGenerator} for the main method, 
	so the KLAIM compiler can then inject its tuple space initialization code 
	directly into the start of the main method, before any processes are 
	activated.
	
	\subsection{In, Out and Read actions}
	
	As we saw in the previous section, the runtime methods for these actions are 
	members of the \textsf{Locality} class in the runtime library. However, that 
	is only part of their implementation, before they can be used someone has to 
	generate the bytecode to call these methods at the appropriate places. For 
	that purpose there are three new syntax tree nodes, \textsf{InAction}, 
	\textsf{OutAction} and \textsf{ReadAction}. These inherit from the 
	\textsf{Action} node from the PLR, and so can be used as children of the 
	PLR's \textsf{ActionPrefix} syntax tree node. These three nodes compile 
	themselves into bytecode that gets the correct locality from the net, and 
	then calls the correct method on that locality. These new action have 
	\textsf{Expression} nodes as children which represent the items in the 
	tuple, one new expression node was added, \textsf{VariableBinding}, other 
	nodes needed were already a part of the PLR.
	
\subsection{Class overview}
	
	Here we quickly go over the main classes used in the KLAIM compiler itself. 	
	\begin{itemize}
	
	\item \textsf{Program} is the main class which parses the command line, 
	validates the given parameters and instantiates the parser. It then gets the 
	syntax tree back from the parser (given that no syntax errors occurred) and 
	instructs the syntax tree to compile itself.
	
	\item \textsf{Scanner} is the lexer class whose responsibility it is to 
	tokenize a KLAIM source code file into valid KLAIM terminals. 
	Listing~\ref{lst:klaimterminals} shows the more complicated terminals of 
	KLAIM defined by regular expressions. The simpler terminals, who are just 
	string constants, are given directly in quotes in the parser definition. 
	
  \item \textsf{Parser} is a recursive-descent parser for KLAIM. The parser 
  constructs a PLR abstract syntax tree as it parses, using both the built in 
  PLR syntax tree nodes and the additional KLAIM syntax tree nodes described 
  below. As with the CCS parser and lexer, this class as well as the 
  \textsf{Scanner} class are generated with help from the Coco/R \cite{cocor} 
  parser generator. The Extended Backus-Naur Form (EBNF) description of the 
  full syntax, which is used as input to Coco/R, is shown in 
  Listing~\ref{lst:klaim_ebnf}.
	
	\item \textsf{InAction, OutAction} and \textsf{ReadAction} are syntax tree 
	nodes for the \textbf{in}, \textbf{out} and \textbf{read} operations 
	respectively. They are stored in the compiler rather than the runtime 
	library since they are only needed at compile time.
	
	\item \textsf{VariableBinding} is a syntax tree node which inherits from 
	\textsf{Expression} and represents the binding of a value from a tuple to a 
	variable.
	
	\end{itemize}
	
\begin{figure}
\lstset{showtabs=false,showspaces=false,showstringspaces=false}
\begin{lstlisting}[caption=Terminals of KLAIM scanner,label=lst:klaimterminals,frame=trbl,basicstyle=\scriptsize\ttfamily,showtabs=false,showspaces=false]
  LOCALITY   = [A-Z][A-Za-z0-9]*
  VARIABLE   = [a-z][A-Za-z0-9]*
  VARBINDING = ![a-z][A-Za-z0-9]*
  NUMBER     = [0-9]+
  \end{lstlisting}
	\end{figure}
	
	\begin{figure}
\lstset{showtabs=false,showspaces=false,showstringspaces=false}
\begin{lstlisting}[caption=EBNF Productions of KLAIM,frame=trbl,label=lst:klaim_ebnf,basicstyle=\scriptsize\ttfamily,showtabs=false,showspaces=false]

KLAIM = 
  LocatedItem { "||" LocatedItem }                

LocatedItem = 
  LOCALITY "::" (Tuple | Process)

Tuple = 
  "<" Constant { "," Constant } ">"

Constant = 
  LOCALITY | NUMBER

Process = 
  ["*"] NonDeterministicChoice

NonDeterministicChoice =  
  ParallelComposition { "+" ParallelComposition }

ParallelComposition = 
  ActionPrefix { "|" ActionPrefix }

ActionPrefix = 
  Action [ "." ActionPrefix
  | "(" Process ")"  
  | "nil"

Action = 
  OutAction | InOrReadAction

OutAction = 
  "out" 
  "(" OutParam { "," OutParam } ")" 
  "@" (LOCALITY | VARIABLE)

OutParam = 
  LOCALITY | Expression

InOrReadAction = 
  ("in"|"read") 
  "(" InOrReadParam {"," InOrReadParam } ")" 
  "@" (LOCALITY | VARIABLE)

InOrReadParam = 
  LOCALITY | VARBINDING | Expression

Expression = 
  PlusMinusTerm { ("+"|"-") PlusMinusTerm }

PlusMinusTerm = 
  UnaryMinusTerm { ("*"|"/"|"\%") UnaryMinusTerm }

UnaryMinusTerm = 
  ["-"] 
  ( 
    "(" Expression ")" 
    | 
    NUMBER 
    | 
    VARIABLE 
  )

	\end{lstlisting}
	\end{figure}


\section{Example of a  KLAIM system}
  ...	

\section{Summary}

	The KLAIM compiler was mainly meant as a proof-of-concept that the PLR could 
	in fact be used and be useful for languages other than CCS. It serves as a 
	case study of how a new language can be implemented fairly quickly by using 
	the PLR as a foundation and adding compile time and/or runtime classes as 
	needed. Although the compiler does not implement the full KLAIM language, it 
	does implement a useful subset of it and could be used as a foundation for 
	adding extensions to, such as implementing AspectK \cite{aspectk}. Another 
	possible extension would be to add the possibility of calling .NET methods, 
	this was not done here as it had already been shown possible in the CCS 
	implementation.
	
	Practical aspects of the compiler (command line parameters, where to 
	download, license etc.) can be found in Appendix A.
