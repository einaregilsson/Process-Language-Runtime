\chapter{KLAIM Implementation}\label{ch:klaim}

	In this chapter we look at the second language implemented using the PLR, 
	the Kernel Language for Agents Interaction and Mobility, or KLAIM. Unlike 
	the CCS implementation, the PLR does not contain all the constructs needed 
	for an implementation of KLAIM, so this chapter is a case study in how the 
	PLR can be extended for use with other languages than CCS.
	
\section{Overview}
	
	KLAIM is a language introduced in 1998 in \cite{klaim}, it's main purpose is 
	to model mobile agents in a distributed environment. It derives many of its 
	constructs from process algebra, but it is also heavily influenced by 
	Linda \cite{linda1, linda2}, a distributed computing solution from which it 
	borrows the concept of \textit{tuple spaces}. A tuple space is a collection 
	of tuples of data, these tuples can be read and removed from the tuple space 
	or new tuples can be added to it. Selecting tuples to read is done by means 
	of pattern matching. In KLAIM, processes run in different 
	\textit{localities}, each of which contains zero or more processes 
	and its own tuple space. The actions performed by the processes input, 
	output and read tuples of data from these tuple spaces. Unlike CCS, where 
	processes synchronized with each other through channels, in KLAIM the way 
	processes communicate is strictly by adding and retrieving data from tuple 
	spaces of different localities. 
	
	The concept of data stores (or tuple spaces) and actions which operate on 
	them is something that is not built into the PLR. KLAIM does however contain 
	many constructs which are a part of the PLR, namely parallel composition, 
	non-deterministic choice and action prefixing (albeit with different type of 
	actions than those built into the PLR). It also contains a fairly common 
	process algebra construct which is not part of the PLR, 
	\textit{replication}. These additional features make KLAIM an ideal 
	candidate to use as a test of how easily the PLR can be extended to 
	accommodate other languages than CCS.
	
	\subsection{The implemented subset of KLAIM}
	
	The implementation of KLAIM described in this chapter is only for a subset 
	of the full language. In particular the \textbf{in}, \textbf{out} and 
	\textbf{read} actions are implemented while the \textbf{eval} and 
	\textbf{newloc} actions are not. The implementation also does not support 
	process constants, processes are defined directly in the \textit{net} and so 
	cannot turn into other processes. The subset of KLAIM implemented here is 
	the same as that described in \cite{aspectk, giordano}, both of which are
	projects developed at the Technical University of Denmark that focus on an 
	aspect-oriented version of KLAIM. Section~\ref{sec:klaim_syntax} only shows 
	syntax and semantic for the subset being used, for a description of the full 
	KLAIM language we refer to \cite{klaim}. 
	
	KLAIMS stated purpose is to be a programming language for programming mobile 
	agents in a distributed environment. However in this implementation all 
	processes in the system are running on the same computer, and in the same 
	(operating system) process. The distributed part of it is purely conceptual. 
	As such, this implementation can be seen more as a simulation of how KLAIM 
	works rather than an implementation ready to be used for actual 
	applications. Examples of other implementations of KLAIM are given in the 
	next section.
		
	\subsection{Other implementations of KLAIM}
		
	Noteworthy implementations of KLAIM include KLAVA\cite{klava}, which is a 
	Java library representing the KLAIM constructs as Java classes, and X-Klaim 
	\cite{xklaim}, a compiler for a superset of KLAIM whose output is Java 
	source code that uses the KLAVA library. A different approach is taken in 
	\cite{giordano} where a virtual machine is developed specifically for 
	AspectK, an aspect-oriented version of KLAIM. A further explanation of these 
	implementations and a comparison with the PLR is given in 
	Section~\ref{sec:related_work}. 

\section{Syntax and semantics}\label{sec:klaim_syntax}
	
	\subsection{Syntax}
	A KLAIM net is made up of located processes and located tuples. We use $N$ 
	for a net and the composition of nodes of the net is given with the 
	$\mid\mid$ operator. We use $P$ and $Q$ for processes and $a$ for actions.
	$x$ is used as a generic variable name, $!x$ represents the binding of a 
	value to variable $x$ and $e$ represents an arithmetic 
	expression. $l$ is a locality constant while $\ell$ can refer to either a 
	locality constant or a variable. $t$ represents a tuple of 
	elements, which can be constants, variables and variable bindings. 
	Located tuples are written as $l::\langle t\rangle$ and 
	located processes as $l::P$. Parallel composition and non-determenistic 
	choice is represented the same way as in CCS, with $+$ and $\mid$ 
	respectively. The replication construct is represented by an asterisk, $*$, 
	immediately preceding a process. Action prefixing is written as $a . P$, and 
	the nil process as \textbf{\textsf{nil}}. Papers on KLAIM traditionally 
	allow the omission of the \textbf{\textbf{nil}} at the end of a process term 
	and so does this implementation, $\mathbf{out}(t)@l . \mathbf{in}(t)@l$ is 
	equivalent to $\mathbf{out}(t)@l . \mathbf{in}(t)@l . \mathbf{nil}$. 
	Figure~\ref{fig:klaim_syntax} shows an overview of the syntax. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[t]
\begin{ARRAY}{r c l l}
		  N & ::= & N_1 \mid\mid\ N_2 & \mathrm{(Net\ composition)}\vspace{3pt}\\
			    & \mid & l::\langle t \rangle & \mathrm{(Located\ tuple)}\vspace{3pt}\\
			    & \mid & l::P & \mathrm{(Located\ process)}\vspace{10pt}\\

			P & ::= & \mathbf{nil} & \mathrm{(Nil\ process)}\vspace{3pt}\\
			    & \mid & a . P & \mathrm{(Action\ prefixing)}\vspace{3pt} \\
			    & \mid & P \mid Q & \mathrm{(Parallel\ composition)}\vspace{3pt}\\
			    & \mid & P + Q & \mathrm{(Nondeterministic\ choice)}\vspace{3pt}\\
			    & \mid & *P  & \mathrm{(Replication)}\vspace{10pt}\\

			a & ::= & \mathbf{out}(t)@\ell\ & \mathrm{(Add\ tuple\ to\ the\ \ell\  tuple\ space)}\vspace{3pt}\\
			
			    & \mid\ & \mathbf{in}(t)@\ell\ & \mathrm{(Remove\ tuple\ from\ the\ \ell\ tuple\ space)}\vspace{3pt}\\

			    & \mid\ & \mathbf{read}(t)@\ell\ & \mathrm{(Read\ tuple\ from\ the\ \ell\ tuple\ space)}\vspace{10pt}\\
			    
			t & ::= & e & \mathrm{(Expression)} \vspace{3pt}\\
			  & \mid & \ell & \mathrm{(Locality\ constant\ or\ variable)} \vspace{3pt}\\
			  & \mid & x & \mathrm{(Variable)} \vspace{3pt}\\
			  & \mid & !x & \mathrm{(The\ binding\ of\ variable\ x)} \vspace{3pt}\\
			  & \mid & t_1,t_2 & \mathrm{(Sequence\ of\ tuple\ elements)} \vspace{3pt}\\
\end{ARRAY}
\caption{KLAIM Nets and processes syntax}
\label{fig:klaim_syntax}
\end{figure}
	
	\subsection{Structural Congruence}
	Figure~\ref{fig:klaim_structural_congruence} shows the structural congruence 
	of net composition, parallel composition and replication. The most 
	interesting thing here for the implementation is that all processes located 
	at the same locality should be treated as a parallel composition process. 
	The replication construct also poses some interesting challenges since
	effectively there can be endless instances of a replicated process. 
	Obviously this is unfeasible for implementation so some solution needs to be 
	worked out that simulates this.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%Structure equivalence
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[t]
\begin{ARRAY}{l@{\qquad\qquad}l}
l:: P_1 \ppar P_2 \equiv l::P_1 \netpar l::P_2 &
l ::\ * P  \equiv l ::\ P \ppar\ * P
\\[2ex]
\Inference{N_1 \equiv N_2}{N \netpar N_1 \equiv N \netpar N_2}
\end{ARRAY}
\caption{KLAIM Structural Congruence.}
\label{fig:klaim_structural_congruence}
\end{figure}


\subsection{Semantics}

%%Semantics
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[t]
\begin{ARRAY}{ll}
%%Out
l_1::\mathbf{out}(t)@l_2.P \rightarrow
l_1::P \netpar l_2::\langle t \rangle
%%In
\\[1ex]
%\begin{array}{r}
l_1::\mathbf{in}(t)@l_2.P \netpar
l_2::\langle t' \rangle \rightarrow l_1::P\theta
 & \hbox{if $match(t;t')= \theta$}
%\end{array}
%%Read
\\[1ex]
%\begin{array}{r}
l_1::\mathbf{read}(t)@l_2.P \netpar
l_2::\langle t' \rangle \rightarrow  l_1::P
\theta \netpar l_2::\langle t' \rangle & 
\hbox{if $match(t;t')= \theta$}
%\end{array}
\\[2ex]
\Inference{ N_1 \rightarrow N_1'}{ N_1 \netpar
N_2 \rightarrow  N_1' \netpar N_2}
\hfill
\hfill
\hfill
\hspace{10pt}
\Inference{N \equiv N'\quad  N' \rightarrow N'' \quad N'' \equiv
N'''}{ N \rightarrow N'''}
\end{ARRAY}
\caption{KLAIM Reaction Semantics (on closed nets).}
\label{fig:klaim_semantics}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


	Since KLAIM has actions that are quite different from those of CCS, we now 
	look closer at those actions. As stated before the operations implemented 
	are \textbf{in}, \textbf{out} and \textbf{read}. The reaction semantics for 
	these operations are shown in Figure~\ref{fig:klaim_semantics}, below is an 
	informal description with examples.
	
	The \textbf{out} operation adds a tuple to the tuplespace of a particular 
	locality. The operation $\mathbf{out}\mathsf{(John,\ Sally)@BusStop}$ adds 
	the tuple $\langle$\textsf{John, Sally}$\rangle$ to the tuplespace at the 
	\textsf{BusStop} locality. The \textbf{out} operation is asynchronous and 
	can never block. This is a big difference from the synchronization actions 
	of CCS which are always dependent on other processes. A KLAIM process 
	composed entirely of \textbf{out} actions can run all the way through 
	without ever stopping because of something other processes are doing.
	
	The \textbf{in} operation removes a tuple from a particular locality's 
	tuplespace if it matches a certain \textit{template}. The template is a 
	tuple which can contain constants, variables and variable bindings. For 
	example the operation $\mathbf{in}\mathsf{(John,\ !other)@BusStop}$ will 
	look in the \textsf{BusStop} locality's tuplespace for a matching tuple, and 
	if it finds one it will be removed and a value bound to the \textsf{other} 
	variable.	The details of matching of templates to tuples is further 
	explained in Section~\ref{klaim_pattern_matching}. One \textbf{in} operation 
	only removes one tuple, if more than one tuple match the pattern then one of 
	them is randomly selected. If no matching tuple exists at the tuplespace the 
	operation will block until one becomes available.

	The \textbf{read} operation is very similar to the \textbf{in} operation; 
	essentially it behaves exactly the same way, except that it does not remove 
	a matching tuple, it just binds values to variables.

\subsection{Pattern matching against tuples}\label{klaim_pattern_matching}
	Figure~\ref{fig:klaim_matching} shows the \textit{match} function used by 
	both the \textbf{in} and \textbf{read} operations. Essentially it works by 
	selecting a tuple from the tuple space that fulfills these conditions:
	
	\begin{enumerate}
		\item The operation tuple $t$ contains the same number of elements as the 
		candidate tuple $t'$ from the tuple space.
		
		\item In every index position $i$ in $t$ which is not a variable binding, 
		the element at $t_i$ is equal to the element at that position in $t$. To 
		put it more succinctly, $t_i$ = $t'_i$ for all $i$ where $t_i$ is not a 
		variable binding.
	\end{enumerate}
	
	If a tuple does not fulfill these conditions it is not selected. If no tuple 
	in the tuple space fulfills the conditions then the process is blocked until 
	the tuplespace acquires such a tuple. The result of the \textit{match} 
	function is a binding of variable names to values according to the variables
	position in the tuple. To give an example of this, suppose we have the 
	following net:
	\begin{verbatim}
		   YellowPages::<John, 352468> 
		   || Sally::read(John, !phonenr)@YellowPages
	\end{verbatim}
	
	The process at locality \textsf{Sally} will match the tuple of the read 
	operation, \textsf{(John, !phonenr)} against the tuple 
	\textsf{$\langle$John, 352468$\rangle$} at the \textsf{YellowPages} 
	locality. Since the first element matches, and the only other element is a 
	variable binding, the tuples match and the value 352468 is bound to the 
	variable \textsf{phonenr} that can then be used in the continuation of the 
	process at locality \textsf{Sally}. 
	
	
%%match
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[t]
\begin{ARRAY}{l}
match(\langle\rangle;\langle\rangle) = id
\\[2ex]
match(\langle t_{1},\cdots,t_k\rangle;\langle t'_1,\cdots,t'_k\rangle)
= \begin{array}[t]{l}
\hbox{let}\ \theta = \hbox{case}\ t_1 \hbox{of}\\
\qquad\qquad \ell:\ \ \hbox{if $t_1 = t'_1$ then $id$ else $fail$}\\
\qquad\qquad !x:\ \ [t'_1/x]\\
\hbox{in } \theta \circ match(\langle
t_2,\cdots,t_k\rangle;\langle t'_2,\cdots,t'_k\rangle)
\end{array}
\end{ARRAY}
\caption{KLAIM Pattern Matching of Templates against Tuples.}
\label{fig:klaim_matching}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%	


\section{Implementation}
	The KLAIM implementation was written in C\# using Visual Studio 2008 as the 
	development environment. It implements the subset of KLAIM described in  
	Section~\ref{sec:klaim_syntax}. KLAIM contains a number of features not 
	available in the PLR, some of these were implemented as syntax tree nodes 
	for the PLR syntax tree while others were implemented in a KLAIM runtime 
	library. The PLR syntax tree nodes for action prefixing, the nil process, 
	parallel composition and nondeterministic choice were used without 
	modification. Expression nodes (constants, variables, arithmetic 
	expressions) could also be re-used so right away the implementation had a 
	number of building blocks ready for use. The main focus was then on the 
	things that differentiate KLAIM from other process languages: its syntax, 
	replication and tuple spaces with their associated \textbf{in}, \textbf{out} 
	and \textbf{read} actions. Each of these is described in the following 
	sections.
	
\subsection{Replication}
	
	Replication is a construct which was quite tricky to implement 
	according to specification. As we saw in 
	Figure~\ref{fig:klaim_structural_congruence} the congruence of replication 
	is defined as
	\begin{center}$l::*P \equiv l::P \mid *P$\end{center}
	so essentially a replicated process is equal to infinite instances of that 
	process running in parallel. For obvious reasons the implementation can not 
	create infinite instances so another solution was needed that mimicked this 
	behavior as closely as possibly. A number of possible approaches were 
	considered for this problem.
	
	The naive approach is to let the replicated process simply keep
	spawning new instances of itself endlessly. The way this could be 
	implemented is by having a small delay between each instantiation of
	the process, to avoid using up all available memory instantly. This
	still has the problem of overshadowing everything else that is going
	on in the system. Consider the case where the first action of a 
	replicated process is an \textbf{out} action, e.g. 
	$\mathbf{out}(X,Y,Z)@Loc$. Over time the $Loc$ locality will fill up
	with $\langle X,Y,Z \rangle$ tuples, making visualization of the net 
	difficult as well as following what actions are happening. This could be 
	partially alleviated by showing tuples that are identical as just one tuple 
	with a number indicating how many of them there are, but that is still a
	hack to cover for an inadequate solution.
		
	Another approach could be to change the semantics of replication
	to that of repetition. That is, instead of defining a replicated
	process as
	\begin{center}$l ::\ *P  \equiv l ::\ P \ppar *P$\end{center}
	it could be defined as
	\begin{center}$l ::\ *P  \equiv l ::\ P .* P$\end{center}
	This is certainly possible to implement and is somewhat similar to 
	replication. There are many ways in which it is different though and
	some hard questions are raised. What should happen to variables that
	are bound in $P$, are their values carried on into the next iteration of 
	$P$, or does the next iteration start with the original values (or lack
	of values) of those variables? Another concern is that if $P$ blocks on
	an action at any point then no new instances of $P$ are spawned until the
	original instance of $P$ continues and finishes. 
		
	The third approach would be to replace infinity with a set number. Instead
	of having infinite instances of $P$ the system would instead have $n$ 
	instances, and $n$ could be configured, for instance with a command line 
	switch. The problem with this is that it turns a behavior that is supposed
	to continue forever into a behavior that ends at a particular time, that is 
	when all $n$ instances have finished.
	
	A fourth approach is to spawn new instances of the process only 
	when needed so that it appears as though there is an infinite amount. The 
	objective is to simulate infinite processes with as few processes as 
	possible, in order to do that it is important to realize where infinite 
	processes give the same result as a single process:
	
	\begin{enumerate}
		\item When a process $P$ is blocked doing an \textbf{in} action, it does 
		not matter whether one instance is blocked or many. The only difference is 
		when an instance becomes unblocked, if there was just one to begin with 
		then no instance is blocked at that action any longer, but if there were 
		$n$ instances blocked there are now $n-1$ instances blocked. This implies
		that if there was just one instance blocked, and another instance was 
		spawned as the first instance unblocked then that would give the same 
		result as having infinite instances blocked. 
	
		\item Since \textbf{read} actions do not change the state of tuple spaces
		in any way, it can be assumed that having one instance of $P$ perform a
		\textbf {read} action or having infinite instances of $P$ perform the 
		action would have the same effect on the state of the tuple spaces, that 
		is, not affect them at all. 
		
		\item Mimicking the \textbf{out} operation is a little more tricky than 
		the other two. Clearly there is a difference between one process 
		performing an \textbf{out} action and multiple processes performing the 
		same action. If multiple processes perform the action then there will be 
		multiple copies of the same tuple (or rather multiple tuples with the same 
		value) at the tuplespace that the action was performed at (ignoring 
		possible differences in variable values). So from the perspective of 
		looking at the tuplespace there clearly is a difference. However, if we 
		consider how this affects the overall system, the behaviour of other 
		processes, then the difference is only apparent when other processes start 
		removing those tuples from the tuplespace. If only one process outputs a 
		tuple $t$ then the next process that tries to remove it will be successful 
		but any subsequent process that tries to remove it will block. However if 
		there were multiple copies of $t$ then no process trying to remove it 
		would block. A possible way to mimic this would be to track each tuple 
		that is output by a replicated process, and if that tuple is removed by 
		another process then a new instance of the replicated process can be 
		spawned which will output a new identical tuple $t$ at the tuplespace, 
		allowing more processes to sucessfully perform an \textbf{in} action at 
		that tuplespace.
	\end{enumerate}
		
	The first attempt at replication tried to use the approach of simulating 
	infinite processes by spawning new instances at certain points in the 
	program. After quite a lot of time had been spent implementing that in a 
	satisfactory way, a number of problems became obvious. These include:
		
	\begin{enumerate}
		\item When the replicated process starts with a \textbf{read} action
		which does not block, followed by an \textbf{out} action that uses 
		variables bound by the previous action, then enough processes must be 
		spawned to account for all possible variations that might have happened.
		Consider the following net:
			
		\begin{verbatim}
			   Loc::<A,1>
			|| Loc::<A,2>
			|| Loc::<A,3>			
			|| Loc::* read(A, !nr)@Loc . out(B, nr)@OtherLoc
		\end{verbatim}
	
	The selection of tuples when more than one match the template is 
	non-deterministic, so the variable $nr$ might be bound to either 1, 2 or 3. 
	Were this done with infinite processes then all of the possibilities would 
	be bound and so the end result would be that \textsf{OtherLoc} ended up 
	having at least one instance of each of the tuples $\langle B, 1 \rangle, 
	\langle B, 2 \rangle$ and $\langle B, 3 \rangle$. To successfully mimic this 
	behaviors would require the program to constantly generate all combinations 
	of what might happen during \textbf{read} actions. This quickly gets 
	complicated, especially when many \textbf{read} actions occur in a row.
	
	\item When there is a non deterministic choice between two or more 
	processes, then it would be necessary to make at least one process take each 
	of the paths, since if there were infinite processes making that choice then 
	surely at least one of them would take each offered choice.
	
	\item Timing issues further complicate matters. Consider the following 
	fragment of a net:
	
		\begin{verbatim}
			Loc::* read(!x)@Loc . in(x, !y)@OtherLoc
		\end{verbatim}
	
	In the solution suggested above a new process would be spawned when the 
	\textbf{in} action would complete. That process would start by reading $x$ 
	at the locality \textsf{Loc}. But if the previous \textbf{in} action was 
	blocked for some amount of time then the contents of \textsf{Loc} might have 
	been changed one or more times in that period. That implies that a process 
	that was spawned after the \textbf{in} action was completed might read a 
	different value of $x$ at \textsf{Loc} than it would have if the two 
	processes were actually started in parallel.
	
	\end{enumerate}
	
	After considering these problems as well as some other exceptions and corner 
	cases it became apparent that	mimicking replication in a general way was not 
	feasible. Instead it was implemented in a restricted way, by requiring that 
	every replicated process starts with an \textbf{in} action. The replicated 
	process itself can then only be an action prefix process, it cannot be a 
	parallel composition or non deterministic choice between processes. It can 
	however start by performing an \textbf{in} action and then turn into a 
	parallel composition or non deterministic choice. The initial \textbf{in} 
	action serves as a guard that blocks until a tuple is available, and as soon 
	as it is unblocked it spawns a new instance of the replicated process. It is 
	intuitively clear that this does in fact preserve the congruence of 
	replication, if there were infinite processes then how many of them would 
	start running would depend on the number of tuples that matched the initial 
	\textbf{in} action, by spawning a new process whenever the first \textbf{in} 
	action has completed the same behavior occurs. 
	
	The semantics of this restricted form of replication are then
	\begin{center}
	$*a . P \infarrow{a} P \mid (*a . P)\ \ \ \mathrm{where}\ a\ \mathrm{is\ an} \ \mathbf{in}\ \mathrm{action}$
	\end{center}
	
	which means that as soon as $a$ has been performed a new $*a . P$ is started.
	A replicated process can be thought of like a server process, it waits until 
	a tuple matching a particular template is available, and then removes it, 
	starts the following process and keeps waiting for a new tuple that matches 
	the template. This is much like how a server works, for instance a webserver 
	that waits for incoming connections, when one is made it starts a worker 
	thread to handle it and keeps listening for further connections.
	
	Other patterns can be simulated within this restricted form, by having a 
	locality whose sole purpose is to contain tuples that start a particular 
	replicated process. Repetition, where one instance of a process finishes 
	before the next instance is started could for example be modelled as
	
		\begin{verbatim}
     StartProc::<1>
     || Loc::* in(!start)@StartProc . out(X)@Y ... (other actions) 
     ... . out(1)@StartProc
		\end{verbatim}
		
  and starting a fixed number $n$ of processes could be done by having $n$ 
  tuples in the initial net that match the initial action, for example

		\begin{verbatim}
     StartProc::<1> || StartProc::<2> || StartProc<3>
     || Loc::* in(!start)@StartProc ....
		\end{verbatim}
	
	would immediately start three instance of the process since three matching 
	tuples are available at \textsf{StartLoc}.

	Implementing this was done by creating a new syntax node, 
	\code{ReplicatedProcess}. That becomes one class, $R$, in the compiled 
	file, and the inner process, $P$, starting with the \textbf{in} action, 
	becomes another class. What $R$ does at runtime is to create a new instance 
	of $P$, give it a reference to itself and call its \code{RunProcess} method
	which runs it on a new thread. It then goes into an infinite loop, which has 
	two steps:
	
	\begin{enumerate}
		\item Suspend the thread that it ($R$) is running on
		\item Once it wakes up, create and start a new instance of $P$ and go to 
		the top of the infinite loop.
	\end{enumerate}
	
	What $P$ does is perform its initial \textbf{in} action, which might block 
	for a while but once the action is finished it checks whether it has a 
	reference to a replicated process, and if it does then it re-activates the 
	thread that the replicated process is running on (which causes the 
	replicated process to continue in its infinite loop). $P$ then continues as 
	normal and is not required to do anything else related to the replication.
	
\subsection{Tuple spaces}

	The tuple spaces of KLAIM are implemented in the KLAIM runtime library. The 
	library consists of just four classes, \code{Net}, \code{Locality}, 
	\code{Tuple} and \code{KLAIMException}. Figure~\ref{fig:klaim_runtime} 
	shows a class diagram of the runtime library.

	\begin{figure}[ht!]
		\centering
		\includegraphics[scale=0.8]{klaim_runtime.jpg}
		\caption{KLAIM runtime library classes}
		\label{fig:klaim_runtime}
	\end{figure}
	
	\begin{itemize}
	
	\item The \code{Net} class represents the entire program, or net, being 
	executed. It does very little itself and only contains a collection of 
	\textsf{Locality} instances as well as methods to add and delete them. 
	
	\item The \code{Locality} class has a name and a collection of tuples, 
	which represents its tuple space. The \textbf{in}, \textbf{out} and 
	\textbf{read} actions are implemented as member methods of this class, this 
	seemed a natural fit since this class holds the tuples. It also contains 
	some convenience methods not available to KLAIM itself, such as methods to 
	check in a non-blocking way if a tuple exists and retrieve a random tuple 
	from the tuple space.

	\item The \code{Tuple} class represents a tuple. As such it holds an 
	ordered collection of items (integers or strings). It also contains the 
	\code{Matches} method, this method implements the template matching 
	against tuples described in Section~\ref{klaim_pattern_matching}.
	
	\item \code{KLAIMException} is a trivial class which just inherits from 
	\code{System.Exception} and whose only purpose is to allow callers to 
	catch a KLAIM specific exception instead of a general one.
	
	\end{itemize}
	
	As seen in these class descriptions, the implementation of tuple spaces is 
	handled by these four classes, \code{Net} holds \code{Locality} 
	instances, they hold collections of \code{Tuple} instances and the methods 
	to access them, and the \code{Tuple}'s implement the pattern matching.
	
	The tuples initially contained in each locality's tuple space need to 
	somehow be put in their place before execution of the net starts. This is an 
	activity that does not really fit into the abstract syntax tree in any 
	particular place. To accomplish this the KLAIM compiler subscribes to the 
	event \code{MainMethodStart} of the \code{ProcessSystem} object, which 
	is the root node of the syntax tree. Then when the syntax tree is compiling 
	itself and is starting to compile the entry method of the program, it raises 
	this event and passes as an event argument the \code{CompileContext} 
	class. It contains an initialized \code{ILGenerator} for the main method, 
	so the KLAIM compiler can then inject its tuple space initialization code 
	directly into the start of the main method, before any processes are 
	activated.
	
	\subsection{In, Out and Read actions}
	
	As we saw in the previous section, the runtime methods for these actions are 
	members of the \code{Locality} class in the runtime library. However, that 
	is only part of their implementation, before they can be used someone has to 
	generate the bytecode to call these methods at the appropriate places. For 
	that purpose there are three new syntax tree nodes, \code{InAction}, 
	\code{OutAction} and \code{ReadAction}. These inherit from the 
	\code{Action} node from the PLR, and so can be used as children of the 
	PLR's \code{ActionPrefix} syntax tree node. These three nodes compile 
	themselves into bytecode that gets the correct locality from the net, and 
	then calls the correct method on that locality. These new action have 
	\code{Expression} nodes as children which represent the items in the 
	tuple, one new expression node was added, \code{VariableBinding}, other 
	nodes needed were already a part of the PLR.
	
	There is one special case for the \textbf{out} action. That is if the 
	locality being output at is named \code{Screen}. In that case the tuple is 
	not stored anywhere, its values are just printed to the screen. For example 
	the action \begin{center}\textsf{out(ResultOfExpression, 3+5)@Screen}\end{center} would produce the output \begin{center}\texttt{ResultOfExpression, 8} \end{center} on the users screen.
	
\subsection{Class overview}
	
	Here we quickly go over the main classes used in the KLAIM compiler itself. 	
	\begin{itemize}
	
	\item \code{Program} is the main class which parses the command line, 
	validates the given parameters and instantiates the parser. It then gets the 
	syntax tree back from the parser (given that no syntax errors occurred) and 
	instructs the syntax tree to compile itself.
	
	\item \code{Scanner} is the lexer class whose responsibility it is to 
	tokenize a KLAIM source code file into valid KLAIM terminals. 
	Figure~\ref{fig:klaimterminals} shows the more complicated terminals of 
	KLAIM defined by regular expressions. The simpler terminals, who are just 
	string constants, are given directly in quotes in the parser definition. 
	
  \item \code{Parser} is a recursive-descent parser for KLAIM. The parser 
  constructs a PLR abstract syntax tree as it parses, using both the built in 
  PLR syntax tree nodes and the additional KLAIM syntax tree nodes described 
  below. As with the CCS parser and lexer, this class as well as the 
  \code{Scanner} class are generated with help from the Coco/R \cite{cocor} 
  parser generator. The Extended Backus-Naur Form (EBNF) description of the 
  full syntax, which is used as input to Coco/R, is shown in 
  Figure~\ref{fig:klaim_ebnf}.
	
	\item \code{InAction}, \code{OutAction} and \code{ReadAction} are syntax 
	tree nodes for the \textbf{in}, \textbf{out} and \textbf{read} operations, 
	respectively. They are stored in the compiler rather than the runtime 
	library since they are only needed at compile time.
	
	\item \code{VariableBinding} is a syntax tree node which inherits from 
	\code{Expression} and represents the binding of a value from a tuple to a 
	variable.
	
	\end{itemize}
	
\begin{figure}
\begin{codeblock}
  LOCALITY   = [A-Z][A-Za-z0-9]*
  VARIABLE   = [a-z][A-Za-z0-9]*
  VARBINDING = ![a-z][A-Za-z0-9]*
  NUMBER     = [0-9]+
\end{codeblock}
	\caption{Terminals of KLAIM scanner}\label{fig:klaimterminals}
	\end{figure}
	
\begin{figure}
\begin{codeblock}
KLAIM = 
  LocatedItem { "||" LocatedItem }                

LocatedItem = 
  LOCALITY "::" (Tuple | Process)

Tuple = 
  "<" Constant { "," Constant } ">"

Constant = 
  LOCALITY | NUMBER

Process = 
  ["*"] NonDeterministicChoice

NonDeterministicChoice =  
  ParallelComposition { "+" ParallelComposition }

ParallelComposition = 
  ActionPrefix { "|" ActionPrefix }

ActionPrefix = 
  Action [ "." ActionPrefix
  | "(" Process ")"  
  | "nil"

Action = 
  OutAction | InOrReadAction

OutAction = 
  "out" 
  "(" OutParam { "," OutParam } ")" 
  "@" (LOCALITY | VARIABLE)

OutParam = 
  LOCALITY | Expression

InOrReadAction = 
  ("in"|"read") 
  "(" InOrReadParam {"," InOrReadParam } ")" 
  "@" (LOCALITY | VARIABLE)

InOrReadParam = 
  LOCALITY | VARBINDING | Expression

Expression = 
  PlusMinusTerm { ("+"|"-") PlusMinusTerm }

PlusMinusTerm = 
  UnaryMinusTerm { ("*"|"/"|"\%") UnaryMinusTerm }

UnaryMinusTerm = 
  ["-"] 
  ( 
    "(" Expression ")" 
    | 
    NUMBER 
    | 
    VARIABLE 
  )

	\end{codeblock}
	\caption{EBNF Productions of KLAIM}
	\label{fig:klaim_ebnf}
	\end{figure}


\section{KLAIM invoice system example}
\begin{figure}
\begin{klaim}  
   Inbox :: <Incoming, Paper, OfficeSupplies, 200, John>
|| Inbox :: <Incoming, Printer, OfficeSupplies, 500, John>  
|| Inbox :: <Incoming, Textbooks, BookShack, 100, Alice>  

|| Ledger :: <Paid, Cake, 50, AlfredosBakery, Alice>

|| Budget :: <John, 2000>
|| Budget :: <Alice, 5000>
  
|| Secretary :: * in(Incoming, !item, !vendor, !amount,  
                     !person)@Inbox 
                . out(Received, item, vendor, amount)@person

|| Secretary :: * in(Denied, !item, !vendor, !amount, !person)@self 
                . out(Denied, item, vendor, amount)@vendor

|| John :: * in(Received, !item, !vendor, !amount)@self
           . 
           (
           out(Confirmed, item, vendor, amount, John)@Finance
           +
           out(Denied, item, vendor, amount, John)@Secretary
           )

|| Alice :: * in(Received, !item, !vendor, !amount)@self
           . 
           (
           out(Confirmed, item, vendor, amount, Alice)@Finance
           +
           out(Denied, item, vendor, amount, Alice)@Secretary
           )

|| Finance :: * in(Confirmed, !item, !vendor, !amount, !person)@self
              . in(person, !budget)@Budget 
              . out(person, budget - amount)@Budget
              . out(Paid, item, vendor, amount, John)@Ledger
	\end{klaim}           
	\caption{Invoice system example in KLAIM}\label{fig:invoice_system}
  \end{figure}

	The preceding sections in this chapter have only presented small snippets of 
	KLAIM code. To get a clearer view of what an actual system modeled in KLAIM 
	might look like, an invoice system example is shown in 
	Figure~\ref{fig:invoice_system}, and explained further below.
	We begin by looking at the localities in the system:
	
	\begin{itemize}
		
		\item \textsf{Inbox} is a locality which contains invoices that have just 
		arrived at the company which the net represents. The \textsf{Inbox} 
		contains no processes, it is just a database for invoices. The invoices 
		themselves are tuples which contain five elements: a status tag, the item 
		being ordered, the vendor name, the price, and the name of the person who 
		ordered the item. For example the tuple $\langle Incoming, Printer, 
		OfficeSupplies, 500, John\rangle$ is an invoice that has the status 
		\textsf{Incoming}, is for a printer that was ordered by John from 
		OfficeSupplies and cost 500.
		
		\item \textsf{Ledger} represents the general ledger of the company. 
		Invoices end up there after they have been confirmed and paid. Every 
		invoice in the ledger should have its status as \textsf{Paid}.
		
		\item The \textsf{Secretary} locality represents the company secretary who 
		removes invoices from the \textsf{Inbox} and then sends them on to the 
		person who ordered the item in question, with a status tag of 
		\textsf{Received}. Note here that the process is replicated and starts 
		with an \textbf{in} action, whenever a invoice (tuple) is available at 
		\textsf{Inbox} whose first element is the constant \textsf{Incoming} a new 
		instance of the \textsf{Secretary} process will be spawned. Also note how 
		the \textbf{in} action binds the variable $person$ and then uses that as 
		the locality in the following action \textbf{out}(...)@person. 
		\textsf{Secretary} also contains another process running in parallel, this 
		process reads in invoices with the status \textsf{Denied} and then sends 
		them back to the vendor that issued the invoice.
		
		\item The localities \textsf{John} and \textsf{Alice} are both employees 
		of the company and have the same process for receiving invoices. They are 
		replicated like the \textsf{Secretary} process so they start whenever a 
		matching tuple lands in their tuple space. They read in the invoice and 
		then have a choice where they can either send it back to the secretary 
		with the status \textsf{Denied} or send it on to the finance department 
		with the status \textsf{Confirmed}.
		
		\item \textsf{Budget} is a database of how much money each employee may 
		spend on outside purchases. It has entries for \textsf{John} and 
		\textsf{Alice} and their current budgets.
		
		\item Finally, \textsf{Finance} is the finance department of the company. 
		It inputs \textsf{Confirmed} invoices from its tuplespace, then subtracts 
		the amount spent from the budget of the person who ordered the item. It 
		does this by first removing the appropriate tuple from \textsf{Budget} by 
		matching on the name on the invoice. It then outputs a new tuple with the 
		current budget which is a result of an evaluated expression, $budget - 
		amount$. The process then ends by adding the invoice to the \textsf{Ledger}
		with a status of \textsf{Paid}.
		
	\end{itemize}
	
	This example system shows how KLAIM can be used to model real world systems. 
	Its high level of abstraction makes it useful for modeling for example 
	workflows without thinking about concrete implementations and technical 
	issues. Localities can be used as simply databases, such as the 
	\textsf{Budget}, as actors, such as \textsf{Secretary}, or as both. This is 
	for example the case with \textsf{John} and \textsf{Alice}, they have 
	processes that they follow, and those processes operate on data in the 
	\textsf{self} tuple space which implies that they own the data. 
	At runtime \textsf{self} simply resolves to the name of the locality where 
	the process is running.

\section{Summary}

	The KLAIM compiler was mainly meant as a proof-of-concept that the PLR could 
	in fact be used and be useful for languages other than CCS. It serves as a 
	case study of how a new language can be implemented fairly quickly by using 
	the PLR as a foundation and adding compile time and/or runtime classes as 
	needed. Although the compiler does not implement the full KLAIM language, it 
	does implement a useful subset of it and could be used as a foundation for 
	adding extensions to, such as implementing AspectK \cite{aspectk}. Another 
	possible extension would be to add the possibility of calling .NET methods, 
	this was not done here as it had already been shown possible in the CCS 
	implementation.
	
	Practical aspects of the compiler (command line parameters, where to 
	download, license etc.) can be found in Appendix A.
